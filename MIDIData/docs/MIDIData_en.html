<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML LANG="ja">
<HEAD>
<TITLE>MIDIDataLibrary Official Guide</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<STYLE TYPE="text/css">
<!--
H1 {FONT-SIZE:36px; BORDER-WIDTH:1px; BORDER-COLOR:#000000; BORDER-STYLE:SOLID; PADDING:20px; BACKGROUND-COLOR:#E0E0D0; TEXT-ALIGN:CENTER;}
H2 {FONT-SIZE:28px; BORDER-WIDTH:1px; BORDER-COLOR:#000000; BORDER-STYLE:SOLID; PADDING:20px; BACKGROUND-COLOR:#E0E0D0}
H3 {FONT-SIZE:24px;}
H4 {FONT-SIZE:16px;}
H5 {FONT-SIZE:14px;}
H6 {FONT-SIZE:12px;}
P {FONT-SIZE:12px; LINE-HEIGHT:18px;}
DIV {FONT-SIZE:12px; LINE-HEIGHT:18px;}
DIV.INDEX {FONT-SIZE:14px; LINE-HEIGHT:18px;}
DIV.TITLE {FONT-SIZE:12px; LINE-HEIGHT:18px;}
SPAN.RED {FONT-SIZE:12px; COLOR:#FF0000; LINE-HEIGHT:18px;}
SPAN.KEYWORD {FONT-SIZE:12px; COLOR:#0000FF; LINE-HEIGHT:18px;}
SPAN.COMMENT {FONT-SIZE:12px; COLOR:#008000; LINE-HEIGHT:18px;}
SPAN.STRING {FONT-SIZE:12px; COLOR:#808000; LINE-HEIGHT:18px;}
LI {FONT-SIZE:12px; LINE-HEIGHT:18px;}
TABLE {FONT-SIZE:12px; LINE-HEIGHT:18px;}
TH {BACKGROUND-COLOR:#FFE0B0; FONT-WEIGHT:NORMAL;}
TR {BACKGROUND-COLOR:#FFFFD0; FONT-WIEGHT:NORMAL;}
PRE {FONT-SIZE:12px; LINE-HEIGHT:18px; BACKGROUND-COLOR:#E0E0E0; PADDING:1px;}
-->
</STYLE>
</HEAD>
<BODY BGCOLOR="#FFFFFFF" ALINK="#0040FF" VLINK="#0040FF">

<H1>MIDIDataLibrary<BR>Official Guide Book<BR><FONT SIZE=3>(C)2002-2020 kuzu / OpenMIDIProject</FONT></H1>

<H3>Introduction</H3>

<P> MIDIDataLibrary is free, open source library for creating and editing MIDI data. It enables you to create and delete MIDI data, import and export Standard MIDI Files (*.mid) format 0/1/2, Sekaiju sequence file (*.skj), Cherry sequence files (*.chy), and MIDICSV files (*.csv), create, delete, add modify MIDI tracks, and create, delete, add and modify MIDI events (including meta events and system exclusive events). This library provides essential functions to access each elements in MIDI data.</P>

<P> For time base, both TPQN base (resolution from 1 to 32767 [ticks/quarter-note]) and SMPTE base (24, 25, 29.97, 30 [frames/sec]) are available. For SMF format, format0, fomat1 and format2 are available. Time base and SMF format can be converted at any time.</P>

<P> This library has functions to convert time stamp to milliseconds or convert millisec to time stamp by analyzing tempo events. This library also has functions to convert time stamp to measure:beat:tick or convert measure:beat:tick to time stamp by analyzing time signature events. Also, this library has functions to get or set title, copyright, comment, start time, end time and so on.</P>

<P> MIDIDataLibrary is written in C, and it is provided not only as a source code but also as a dynamic link library (*.dll). So you can use this library not only from C/C++, but also Visual Basic or Delphi. Latest MIDIDataLibrary can be downloaded from <A HREF="https://openmidiproject.osdn.jp/index.html">OpenMIDIProject</A>.</P>

<P> This is MIDIDataLibrary's official guide book. <SPAN CLASS="RED">This is not standard MIDI file(*.mid)'s specification book.</SPAN> But all structure and function name are based on standard MIDI file, so standard MIDI file's knowledge will help you very much.</P>

<P> To read this book, you are required C language's basical knowledge, such as structure and pointer. About C language, please read commercially available books.</P>

<H3>Acknowledgment</H3>

<P> MIDIDataLibrary has been developed for several years to become the core of all MIDI programs. At that time, I needed MIDIDataLibrary to create or edit MIDIData to make RPG or MIDI sequencer, and I searched it. There were a lot of graphics and audio library but no MIDI library. So I decided to make this library.</P>

<P> It is miraculous that I could release this library. In Japan, company is very very hard, which is known as "karoshi". I didn't have a time to make this, and I was too tired and sleepy because of overwork. And I fainted in the train and falled in to a coma.</P>

<P> At first, I'm thanks to syokobusoft's friends. There are experienced programmers in syokobusoft. Without them, this library were not released. Especially, Mr. Amashin is important person. Without him, I wouldn't know C language and MIDI. And special thanks to my family.</P>

<H3>Index</H3>
<DIV CLASS="INDEX"><A HREF="#MIDIOverview">Chapter1. Overview</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_MIDI">1-1. About MIDI</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_MIDIData">1-2. About MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_Structure">1-3. Structure of MIDIDataLibrary</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_Create">1-4. How to make MIDIData by using MIDIDataLibrary</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_Print">1-5. How to show MIDIData by using MIDIDataLibrary</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_ANSI_UNICODE">1-6. ANSI version and UNICODE version</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIOverview_SetDefaultCharCode">1-7. MIDIDataLib_SetDefaultCharCode</A></DIV>
<DIV CLASS="INDEX"><A HREF="#MIDIData">Chapter2. MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_Struct">2-1. Strucutre of MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_Format">2-2. MIDIData's format</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_TimeBase">2-3. MIDIData's time base</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_CreateFunction">2-4. Create MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_DeleteFunction">2-5. Delete MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_LoadFunction">2-6. Load MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_SaveFunction">2-7. Save MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_InsertTrackFunction">2-8. Insert MIDITrack to MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_RemoveTrackFunction">2-9. Remove MIDITrack from MIDIData</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_GetFunction">2-10. Get MIDIData's property</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_SetFunction">2-11. Set MIDIData's property</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_OtherFunction">2-12. Other MIDIData's feature</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIData_forEachTrack">2-13. forEachTrack</A></DIV>
<DIV CLASS="INDEX"><A HREF="#MIDITrack">Chapter3. MIDITrack</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_Struct">3-1. Structure of MIDITrack</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_Status">3-2. MIDITrack's status</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_CreateFunction">3-3. Create MIDITrack</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_DeleteFunction">3-4. Delete MIDITrack</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_InsertEventFunction">3-5. Insert MIDIEvent to MIDITrack</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_RemoveEventFunction">3-6. Remove MIDIEvent from MIDITrack</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_IsFunction">3-7. Test MIDITrack's status</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_GetFunction">3-8. Get MIDITrack's property</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_SetFunction">3-9. Set MIDITrack's property</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_OtherFunction">3-10. Other MIDITrack's feature</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDITrack_forEachEvent">3-11. forEachEvent</A></DIV>
<DIV CLASS="INDEX"><A HREF="#MIDIEvent">Chapter4. MIDIEvent</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_Struct">4-1. Structure of MIDIEvent</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_Kind">4-2. MIDIEvent's kind</A></DIV>
<DIV CLASS="INDEX">　　　　<A HREF="#MIDIEvent_MetaEvent">4-2-1. Meta Event</A></DIV>
<DIV CLASS="INDEX">　　　　<A HREF="#MIDIEvent_MIDIChannelEvent">4-2-2. MIDI Channel Event</A></DIV>
<DIV CLASS="INDEX">　　　　<A HREF="#MIDIEvent_SysExEvent">4-2-3. System Exclusive Event</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_Status">4-3. MIDIEvent's status</A></DIV>
<DIV CLASS="INDEX">　　　　<A HREF="#MIDIEvent_FloatingEvent">Floating</A></DIV>
<DIV CLASS="INDEX">　　　　<A HREF="#MIDIEvent_CombinedEvent">Combined</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_CreateFunction">4-4. Create MIDIEvent</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_DeleteFunction">4-5. Delete MIDIEvent</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_IsFunction">4-6. Test MIDIEvent's status</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_GetFunction">4-7. Get MIDIEvent's property</A></DIV>
<DIV CLASS="INDEX">　　<A HREF="#MIDIEvent_SetFunction">4-8. Set MIDIEvent's property</A></DIV>
<DIV CLASS="INDEX"><A HREF="#APPENDIX_A">Appendix A　F.A.Q</A></DIV>
<DIV CLASS="INDEX"><A HREF="#APPENDIX_B">Appendix B　Note.Key, Drum.Key, Control Change, Program Change table</A></DIV>
<DIV CLASS="INDEX"><A HREF="#APPENDIX_C">Appendix C　MIDIEvent_Set/Get Function support table</A></DIV>
<DIV CLASS="INDEX"><A HREF="#APPENDIX_D">Appendix D　History</A></DIV>


<H2><A NAME="MIDIOverview">Chapter1. OverView</A></H2>


<H3><A NAME="MIDIOverview_MIDI">1-1. About MIDI</A></H3>

<P> MIDI is <U>M</U>usical <U>I</U>nstrument <U>D</U>igital <U>I</U>nterface, and it is transmission protocol between electronic instruments. You can use MIDI module by playing MIDI keyboard. You can also use MIDI module from MIDI sequencer on the computer to play stored MIDIData.</P>

<DIV>▼Fig1-1-1 Constitution of MIDI (Musical Instruments Digital Interface)</DIV>
<IMG SRC="MIDIDR02.gif" WIDTH=600 HEIGHT=360 ALT="">

<H3><A NAME="MIDIOverview_MIDIData">1-2. About MIDIData</A></H3>

<P> MIDIData contains informations how to play electronic instruments. MIDIData has single or multiple MIDITrack in it, and each track has MIDIEvents, which has time stamp and command information.</P>

<DIV>▼Fig1-2-1 Constitution of MIDIData</DIV>
<IMG SRC="MIDIDR03.gif" WIDTH=600 HEIGHT=525 ALT="">

<P> MIDIData is often treated as audio data such as wave data or mp3 data, but it is wrong. MIDIData deos not has audio data, but has performance command data such as press "C" or press pedal. Audio data is generated by external tone generator, which is generally called "MIDI module" or "Synthsizer", so sound quality is completely depend on which tone generator you use.</P>

<H3><A NAME="MIDIOverview_Structure">1-3. Structure of MIDIDataLibrary</A></H3>

<P> MIDIDataLibrary defines three structures, which is, <A HREF="#MIDIData">MIDIData</A>, <A HREF="#MIDITrack">MIDITrack</A>, <A HREF="#MIDIEvent">MIDIEvent</A>. MIDITrack is child of MIDIData, and MIDIEvent is child of MIDITrack. MIDITrack's parent is MIDIData, and MIDIEvent's parent is MIDITrack. Each MIDITrack is connected by list pointer, and each event is connected by list pointer. You can use each object's pointer by using MIDIData_GetFirstTrack, MIDIData_GetLastTrack, MIDITrack_GetParent, MIDITrack_GetNextTrack, MIDITrack_GetPrevTrack, MIDITrack_GetFirstEvent, MIDITrack_GetLastEvent, MIDIEvent_GetParent, MIDIEvent_GetNextEvent, MIDIEvent_GetPrevEvent.</P>

<DIV>▼Fig1-3-1 Structure of MIDIDataLibrary</DIV>
<IMG SRC="MIDIDR01.gif" WIDTH=640 HEIGHT=480 ALT="MIDIデータの全体構成図">
<H3><A NAME="MIDIOverview_Create">1-4. How to make MIDIData by using MIDIDataLibrary</A></H3>

<P> Here is a short example program that makes "Chocho"'s MIDIData. This music's tempo is 120, and program name is piano, and melody is "GEE-, FDD-, CDEFGGG-".</P>

<DIV>▼Fig1-4-1 Score of "Chocho"</DIV>
<IMG SRC="MIDIDR04.gif" WIDTH=400 HEIGHT=100 ALT="Score of Chocho">

<DIV>▼List1-4-1 Sample program to make "Chocho"'s MIDIData</DIV>
<PRE>
<SPAN CLASS="KEYWORD">#include</SPAN> &lt;stdio.h&gt;
<SPAN CLASS="KEYWORD">#include</SPAN> &lt;MIDIData.h&gt;
<SPAN CLASS="KEYWORD">int</SPAN> main () {
	MIDIData* pMIDIData;
	MIDITrack* pMIDITrack;
	<SPAN CLASS="COMMENT">/* Create MIDIData (Format=0, NumTracks=1,TPQNBase, 120) */</SPAN>
	pMIDIData = MIDIData_Create (MIDIDATA_FORMAT0, 1, MIDIDATA_TPQNBASE, 120);
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDIData == NULL) {
		printf (<SPAN CLASS="STRING">"MIDIData_Create failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Get pointer of the first track */</SPAN>
	pMIDITrack = MIDIData_GetFirstTrack (pMIDIData);
	<SPAN CLASS="COMMENT">/* Insert Event */</SPAN>
	MIDITrack_InsertTrackName (pMIDITrack, 0, "Chocho"); <SPAN CLASS="COMMENT">/* Title */</SPAN>
	MIDITrack_InsertTempo (pMIDITrack, 0, 60000000 / 120); <SPAN CLASS="COMMENT">/* 120BPM */</SPAN>
	MIDITrack_InsertProgramChange (pMIDITrack, 0, 0, 0); <SPAN CLASS="COMMENT">/* Piano1 */</SPAN>
	<SPAN CLASS="COMMENT">/* Insert note event            Time  ch  key  vel  dur */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,     0,  0,  67, 100, 120); <SPAN CLASS="COMMENT">/* G */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   120,  0,  64, 100, 120); <SPAN CLASS="COMMENT">/* E */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   240,  0,  64, 100, 240); <SPAN CLASS="COMMENT">/* E- */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   480,  0,  65, 100, 120); <SPAN CLASS="COMMENT">/* F */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   600,  0,  62, 100, 120); <SPAN CLASS="COMMENT">/* D */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   720,  0,  62, 100, 240); <SPAN CLASS="COMMENT">/* D- */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   960,  0,  60, 100, 120); <SPAN CLASS="COMMENT">/* C */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,  1080,  0,  62, 100, 120); <SPAN CLASS="COMMENT">/* D */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,  1200,  0,  64, 100, 120); <SPAN CLASS="COMMENT">/* E */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,  1320,  0,  65, 100, 120); <SPAN CLASS="COMMENT">/* F */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,  1440,  0,  67, 100, 120); <SPAN CLASS="COMMENT">/* G */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,  1560,  0,  67, 100, 120); <SPAN CLASS="COMMENT">/* G */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,  1680,  0,  67, 100, 240); <SPAN CLASS="COMMENT">/* G- */</SPAN>
	<SPAN CLASS="COMMENT">/* Insert end of track event */</SPAN>
	MIDITrack_InsertEndofTrack (pMIDITrack, 1920);
	<SPAN CLASS="COMMENT">/* Save MIDIData */</SPAN>
	MIDIData_SaveAsSMF (pMIDIData, <SPAN CLASS="STRING">"chocho.mid"</SPAN>);
	<SPAN CLASS="COMMENT">/* Delete MIDIData */</SPAN>
	MIDIData_Delete (pMIDIData);
	pMIDIData = NULL;
	<SPAN CLASS="KEYWORD">return</SPAN> 1;
}
</PRE>

<P> In this program, at first, create MIDIData which has single track on the memory by using <A HREF="#MIDIData_Create">MIDIData_Create</A> function. Then, insert track name, tempo, program change, note, end of track event to the first track by using <A HREF="#MIDITrack_InsertTrackName">MIDITrack_InsertTrackName</A>function, <A HREF="#MIDITrack_InsertTempo">MIDITrack_InsertTempo</A>function, <A HREF="#MIDITrack_InsertProgramChange">MIDITrack_InsertProgramChange</A>function, <A HREF="#MIDITrack_InsertNote">MIDITrack_InsertNote</A> and <A HREF="#MIDITrack_InsertEndofTrack">MIDITrack_InsertEndofTrack</A> function. Then, save the MIDIData to file as a standard MIDI file(*.mid) by using <A HREF="#MIDIData_SaveAsSMF">MIDIData_SaveAsSMF</A> function. Finally, delete the MIDIData on the memory by using <A HREF="#MIDIData_Delete">MIDIData_Delete</A> function.</P>

<P> By running this program, a file whose name is "chocho.mid" is generated. This file can be played by windows media player. This file is a standard MIDI file (*.mid) format0.</P>


<H3><A NAME="MIDIOverview_Print">1-5. How to show MIDIData by using MIDIDataLibrary</A></H3>

<P> Here is a short example to show MIDIData.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_Dump1">▼List1-5-1. A short example program to show MIDIData</A></DIV>
<PRE>
<SPAN CLASS="KEYWORD">#include</SPAN> &lt;stdio.h&gt;
<SPAN CLASS="KEYWORD">#include</SPAN> &lt;MIDIData.h&gt;
<SPAN CLASS="KEYWORD">int</SPAN> main () {
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDIData* pMIDIData;
	MIDITrack* pMIDITrack;
	MIDIEvent* pMIDIEvent;
	<SPAN CLASS="COMMENT">/* Load MIDIData from Standard MIDI file(*.mid) */</SPAN>
	pMIDIData = MIDIData_LoadFromSMF (<SPAN CLASS="STRING">"chocho.mid"</SPAN>);
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDIData == NULL) {
		printf (<SPAN CLASS="STRING">"MIDIData_LoadFromSMF failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Print MIDIData's property */</SPAN>
	printf (<SPAN CLASS="STRING">"[MIDIData]\n"</SPAN>);
	printf (<SPAN CLASS="STRING">"Format=%d\n"</SPAN>, MIDIData_GetFormat (pMIDIData));
	printf (<SPAN CLASS="STRING">"NumTracks=%d\n"</SPAN>, MIDIData_GetNumTrack (pMIDIData));
	printf (<SPAN CLASS="STRING">"TimeMode=%d\n"</SPAN>, MIDIData_GetTimeMode (pMIDIData));
	printf (<SPAN CLASS="STRING">"TimeResolution=%d\n"</SPAN>, MIDIData_GetTimeResolution (pMIDIData));
	<SPAN CLASS="COMMENT">/* Print each MIDITrack */</SPAN>
	forEachTrack (pMIDIData, pMIDITrack) {
		printf (<SPAN CLASS="STRING">"[MIDITrack]\n"</SPAN>);
		printf (<SPAN CLASS="STRING">"Measure:Beat:Tick Kind             Len  Data\n"</SPAN>);
		<SPAN CLASS="COMMENT">/* Print each MIDIEvent */</SPAN>
		forEachEvent (pMIDITrack, pMIDIEvent) {
			printf (<SPAN CLASS="STRING">"%s\n"</SPAN>, MIDIEvent_ToString (pMIDIEvent, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
		}
	}
	<SPAN CLASS="COMMENT">/* Delete MIDIData on the memory */</SPAN>
	MIDIData_Delete (pMIDIData);
	<SPAN CLASS="KEYWORD">return</SPAN> 1;
}
</PRE>

<P> For the first, this program load MIDIData from standard MIDI file(*.mid) by using <A HREF="#MIDIData_LoadFromSMF">MIDIData_LoadFromSMF</A>. Then print MIDIData's property, which is, <A HREF="#MIDIData_Format">Format</A>, Number of tracks, <A HREF="#MIDIData_TimeBase">Time mode</A>, and <A HREF="#MIDIData_TimeBase">Resolution</A>[Ticks per quarter note], by using <A HREF="#MIDIData_GetFormat">MIDIData_GetFormat</A>, <A HREF="#MIDIData_GetNumTrack">MIDIData_GetNumTrack</A>, <A HREF="#MIDIData_GetTimeMode">MIDIData_GetTimeMode</A>, <A HREF="#MIDIData_GetTimeResolution">MIDIData_GetTimeResolution</A> function. To get each MIDITrack's pointer from MIDIData, use <A HREF="#forEachTrack">forEachTrack</A> macro. To get each MIDIEvent's pointer from MIDITrack, use <A HREF="#forEachEvent">forEachEvent</A> macro. To show each event as string, use MIDIEvent_ToString function which is only for debug, and unofficial function.</P>

<P> Here is a short example dump list. Be careful that <A HREF="#MIDITrack_InsertNote">MIDITrack_InsertNote</A> function insert two events, which is, <A HREF="#MIDIEvent_NoteOn">note on</A> event and <A HREF="#MIDIEvent_NoteOff">note off</A> event. In standard MIDI file(*.mid), note on and note off is separated event.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_Dump2">▼List1-5-2. Dump list</A></DIV>
<PRE>
[MIDIData]
Foramat=0
NumTracks=1
TimeMode=0
Resolution=120
[MIDITrack]
Measure:Beat:Tick Kind             Len  Data
00000:00:000 TrackName            6 {"Chocho"}
00000:00:000 Tempo                3 {500000[microsec/beat](120[BPM])}
00000:00:000 ProgramChange        2 {0xC0    0}
00000:00:000 NoteOn               3 {0x90  G_5  100       120}
00000:01:000 NoteOff              3 {0x90  G_5    0      -120}
00000:01:000 NoteOn               3 {0x90  E_5  100       120}
00000:02:000 NoteOff              3 {0x90  E_5    0      -120}
00000:02:000 NoteOn               3 {0x90  E_5  100       240}
00001:00:000 NoteOff              3 {0x90  E_5    0      -240}
00001:00:000 NoteOn               3 {0x90  F_5  100       120}
00001:01:000 NoteOff              3 {0x90  F_5    0      -120}
00001:01:000 NoteOn               3 {0x90  D_5  100       120}
00001:02:000 NoteOff              3 {0x90  D_5    0      -120}
00001:02:000 NoteOn               3 {0x90  D_5  100       240}
00002:00:000 NoteOff              3 {0x90  D_5    0      -240}
00002:00:000 NoteOn               3 {0x90  C_5  100       120}
00002:01:000 NoteOff              3 {0x90  C_5    0      -120}
00002:01:000 NoteOn               3 {0x90  D_5  100       120}
00002:02:000 NoteOff              3 {0x90  D_5    0      -120}
00002:02:000 NoteOn               3 {0x90  E_5  100       120}
00002:03:000 NoteOff              3 {0x90  E_5    0      -120}
00002:03:000 NoteOn               3 {0x90  F_5  100       120}
00003:00:000 NoteOff              3 {0x90  F_5    0      -120}
00003:00:000 NoteOn               3 {0x90  G_5  100       120}
00003:01:000 NoteOff              3 {0x90  G_5    0      -120}
00003:01:000 NoteOn               3 {0x90  G_5  100       120}
00003:02:000 NoteOff              3 {0x90  G_5    0      -120}
00003:02:000 NoteOn               3 {0x90  G_5  100       240}
00004:00:000 NoteOff              3 {0x90  G_5    0      -240}
00004:00:000 EndofTrack           0 {}
</PRE>



<H3><A NAME="MIDIOverview_ANSI_UNICODE">1-6. ANSI version and UNICODE version</A></H3>

<P> Since MIDIDataLibrary2.6, MIDIDataLibrary corresponds to both ANSI version and Unicode version. If you are using elariler version, you must compile your program again.</P>

<P> You can select which mode to use by writing #define UNICODE in your program or not. If you write #define UNICODE, MIDIDataLibrary use Unicode version's function. Else, MIDIDataLibrary use ANSI version's function.</P>

<H4>Pointer to string in the structure is not char* type, but void* type</H4>

<P >Each pointer to string in the structure is not <SPAN class="keyword">char</SPAN>* type, but <SPAN class="keyword">void</SPAN>* type, in order to support both ANSI and Unicode.</P>

<H4>Pointer to string in the function is not char* type, but TCHAR* type</H4>

<P> If a function has a pointer to string in the parameter or return value, the type of string is not char* type, but TCHAR* type. TCHAR is defined in microsoft windows. It is char* type in ANSI but it is wchar_t* type in Unicode.</P>

<PRE>
<SPAN class="keyword">#ifdef</SPAN> UNICODE
<SPAN class="keyword">typedef</SPAN> TCHAR wchar_t;
<SPAN class="keyword">#else</SPAN>
<SPAN class="keyword">typedef</SPAN> TCHAR <SPAN class="keyword">char</SPAN>;
<SPAN class="keyword">#endif</SPAN>
</PRE>

<P> There are two type of actual function, which is for ANSI version and for Unicode version. It is same as Window API function. Programmer doesn't need to select which function to use because by #ifdef macro MIDIDataLibrary automatically use your verison's function.</P>

<PRE>
MIDIData* MIDIData_LoadFromSMFA (<SPAN class="keyword">const char</SPAN>* pszFileName);
MIDIData* MIDIData_LoadFromSMFW (<SPAN class="keyword">const</SPAN> wchar_t* pszFileName);
<SPAN class="keyword">#ifdef</SPAN> UNICODE
MIDIData_LoadFromSMF MIDIData_LoadFromSMFW
<SPAN class="keyword">#else</SPAN>
MIDIData_LoadFromSMF MIDIData_LoadFromSMFA
<SPAN class="keyword">#endif</SPAN>
</PRE>

<H4>Length of string is sizeof(TCHAR) unit</H4>

<P> Length of string is not bytes unit, but sizeof(TCHAR) unit. One character is 1byte in ANSI, but one character is 2bytes in Unicode.</P>

<H3><A NAME="MIDIOverview_SetDefaultCharCode">1-7. MIDIDataLib_SetDefaultCharCode</A></H3>

<P> MIDIData has no char code information. So you must specify MIDIDataLibrary's text encoder's default char code by using MIDIData_SetDefaultCharCode. This setup is used for set or get text event's string which has no char code identifier. If you doesn't specify any char code, MIDIEVENT_NOCHARCODE is applied. If MIDIEVENT_NOCHARCODE, the text encoding specified in the windows's control panel is applied.</P>

<DIV CLASS="TITLE"><A NAME="MIDIDataLib_SetList">▼List1-7. How to use MIDIDataLib_Set functions</A></DIV>
<PRE>
	MIDIDataLib_SetDefaultCharCode (MIDIEVENT_JP);
</PRE>

<DIV CLASS="TITLE"><A NAME="MIDIDataLib_SetTable">▼Table1-7. Table of MIDIDataLib_Set functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIDataLib_SetDefaultCharCode"><SPAN CLASS="KEYWORD">long</SPAN> MIDIDataLib_SetDefaultCharCode<BR>(<SPAN CLASS="KEYWORD">long</SPAN> lCharCode);</A> </TD>
  <TD>lCharCode : (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR></TD>
  <TD>Successful 1 : Failed 0</TD>
  <TD>Select MIDIDataLibrary's default text encoder / decoder. This function affect to <A HREF="#MIDITrack_InsertTextEvent">MIDITrack_InsertTextEvent</A>, <A HREF="#MIDITrack_InsertCopyrightNotice">MIDITrack_InsertCopyrightNotice</A>, <A HREF="#MIDITrack_InsertTrackName">MIDITrack_InsertTrackName</A>, <A HREF="#MIDITrack_InsertInstrumentName">MIDITrack_InsertInstrumentName</A>, <A HREF="#MIDITrack_InsertLyric">MIDITrack_InsertLyric</A>, <A HREF="#MIDITrack_InsertMarker">MIDITrack_InsertMarker</A>, <A HREF="#MIDITrack_InsertCuePoint">MIDITrack_InsertCuePoint</A>, <A HREF="#MIDITrack_InsertProgramName">MIDITrack_InsertProgramName</A>, <A HREF="#MIDITrack_InsertDeviceName">MIDITrack_InsertDeviceName</A>, <A HREF="#MIDIEvent_CreateTextEvent">MIDIEvent_CreateTextEvent</A>, <A HREF="#MIDIEvent_CreateCopyrightNotice">MIDIEvent_CreateCopyrightNotice</A>, <A HREF="#MIDIEvent_CreateTrackName">MIDIEvent_CreateTrackName</A>, <A HREF="#MIDIEvent_CreateInstrumentName">MIDIEvent_CreateInstrumentName</A>, <A HREF="#MIDIEvent_CreateLyric">MIDIEvent_CreateLyric</A>, <A HREF="#MIDIEvent_CreateMarker">MIDIEvent_CreateMarker</A>, <A HREF="#MIDIEvent_CreateCuePoint">MIDIEvent_CreateCuePoint</A>, <A HREF="#MIDIEvent_CreateProgramName">MIDIEvent_CreateProgramName</A>, <A HREF="#MIDIEvent_CreateDeviceName">MIDIEvent_CreateDeviceName</A>, <A HREF="#MIDIEvent_GetText">MIDIEvent_GetText</A>, <A HREF="#MIDIEvent_SetText">MIDIEvent_SetText</A>, MIDIEvent_ToString, MIDIEvent_ToStringEx.</TD>
 </TR>
</TABLE>


<H2><A NAME="MIDIData">Chapter2. MIDIData</A></H2>

<H3><A NAME="MIDIData_Struct">2-1. Structure of MIDIData</A></H3>

<P>MIDIData has three property, which is, <A HREF="#MIDIData_Format">Format</A>, Number of Tracks, Timebase (time mode and resolution), and has single or multiple MIDITrack as a child.</P>

<P><SPAN CLASS="RED">MIDIData's title and copyright, which is often shown as a MIDIData's property, are not MIDIData's property, but the first track's the first <A HREF="#MIDIEvent_TrackName">track name</A> or <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_FieldTable">▼Table2-1. MIDIData structure's field.</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Field</TH>
  <TH WIDTH="75%">Descriiption</TH>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lFormat</TD>
  <TD><A HREF="#MIDIData_FormatTable">Format</A>。Must be <A HREF="#MIDIData_Format0">MIDIDATA_FORMAT0(=0)</A>, <A HREF="#MIDIData_Format1">MIDIDATA_FORMAT1(=1)</A>, or <A HREF="#MIDIData_Format2">MIDIDATA_FORMAT2(=2)</A>.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lNumTrack</TD>
  <TD>Number of Track (1 ~ 65535). Updated by using <A HREF="#MIDIData_CountTrack">MIDIData_CountTrack</A>.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lTimeBase</TD>
  <TD><A HREF="#MIDIData_TimeBase">Timebase</A>。Contains both time mode and resolution. m_lTimeBase's value is ((256 - time mode) &lt;&lt; 8) + resolution.</TD>
 </TR>
 <TR>
  <TD>MIDITrack* m_pFirstTrack</TD>
  <TD>Pointer to the first <A HREF="#MIDITrack">MIDITrack</A>. If has no track, must be NULL.</TD>
 </TR>
 <TR>
  <TD>MIDITrack* m_pLastTrack</TD>
  <TD>Pointer to the last <A HREF="#MIDITrack">MIDITrack</A>. If has no track, must be NULL.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser1</TD>
  <TD>32bit User area. This value is not saved in Standard MIDI File (*.smf).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser2</TD>
  <TD>32bit User area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser3</TD>
  <TD>32bit User area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUserFlag</TD>
  <TD>32bit User area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_Format">2-2. MIDIData's format</A></H3>

<P> There are three format type, which is, format0 / 1 / 2. Following is each format's description.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_FormatTable">▼Table2-2. MIDIData's format and descrription</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="20%">ID</TH>
  <TH WIDTH="20%">Format</TH>
  <TH WIDTH="60%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_Format0">MIDIDATA_FORMAT0 (=0)</A></TD>
  <TD>format0</TD>
  <TD>Format0's MIDIData only has single <A HREF="#MIDITrack">MIDITrack</A> which contain's all kind of <A HREF="#MIDIEvent">MIDIEvent</A>. Though it has only one track, each event has channel information, so you can use 16 channels. In the XF data (YAMAHA's extended format), it has 3 tracks. In this case, the second and third track is XF specified format.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_Format1">MIDIDATA_FORMAT1 (=1)</A></TD>
  <TD>format1</TD>
  <TD>Format1's MIDIData has multiple <A HREF="#MIDITrack">MIDITrack</A>. <SPAN CLASS="RED">The first track is called "Conductor track", which can be used for only <A HREF="#MIDIEvent_Marker">marker</A>, <A HREF="#MIDIEvent_CuePoint">cue point</A>, <A HREF="#MIDIEvent_Tempo">tempo</A>, <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A>, <A HREF="#MIDIEvent_TimeSignature">time signature</A>, <A HREF="#MIDIEvent_KeySignature">key signature</A> and so on. <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event </A> such as note on must be placed in the second or follwoing tracks.</SPAN> <SPAN CLASS="RED">Each track is allowed to contain only single channel's event.</SPAN> This format also can be used to perform multiple MIDI sound module.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_Format2">MIDIDATA_FORMAT2 (=2)</A></TD>
  <TD>format2</TD>
  <TD>Format2's MIDIData has multiple <A HREF="#MIDITrack">MIDITrack</A>. Each track has independent music and used for to play with changing music. Each track isn't played at the same time. Each track can contain all kind of <A HREF="#MIDIEvent">event</A>. This format is seldom used, so unrecommmended.</TD>
 </TR>
</TABLE>

<P>You can get MIDIData's format by using <A HREF="#MIDIData_GetFormat">MIDIData_GetFormat</A> function. And you can convert MIDIData's format by using <A HREF="#MIDIData_SetFormat">MIDIData_SetFormat</A> funcition. Be careful conversion format may cause loss a part of information.</P>

<H3><A NAME="MIDIData_TimeBase">2-3. MIDIData's TimeBase</A></H3>

<P> MIDIData's timebase define the MIDIData's time format. Timebase consists of time mode and time resolution. Time mode may be <A HREF="#MIDIDATA_TPQNBASE">TPQN base</A> or<A HREF="#MIDIDATA_SMPTEBASE">SMPTE base</A>. Time resolution is a resolution per quarter note or 1 frame.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_TimeModeTable">▼Table2-3.Timemode's description</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">ID</TH>
  <TH WIDTH="25%">Time mode</TH>
  <TH WIDTH="50%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIDATA_TPQNBASE">MIDIDATA_TPQNBASE (=0)</A></TD>
  <TD>TPQN base</TD>
  <TD> TPQN(<U>T</U>icks <U>P</U>er <U>Q</U>uater <U>N</U>ote) base's MIDIData is based on quarter note's length. The minimum unit of time is [tick], The resolution per quarter note may be 48, 96, 120, 144, 192, 240, 360, 480, 960 and so on. For example, time resolution is 120, quarver note's length is 60 and quarter note's length is 120 and half note's length is 240. If this value is higher, though each event's time can be specified more accurately, but too high resolution make it impossible to make long music. This value is generally 120 or 480. The speed of playing depends on <A HREF="#MIDIEvent_Tempo">Tempo</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIDATA_SMPTEBASE"></A><A NAME="MIDIDATA_SMPTE24BASE">MIDIDATA_SMPTE24BASE (=24)</A></TD>
  <TD>SMPTE base 24 frames / sec</TD>
  <TD ROWSPAN=4> SMPTE base's MIDIData is based on movie's frame. There is no concept of tempo. Time mode's value can be number of frames, 24, 25, 29(for 29.97) or 30. Time resolution means number of subframe per frame. If time mode is MIDIDATA_SMPTE25BASE and time resolution is 40, the resolution per 1sec is just be 1000, so you can make 1 msec unit's MIDIData.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIDATA_SMPTE25BASE">MIDIDATA_SMPTE25BASE (=25)</A></TD>
  <TD>SMPTE base 25 frames / sec</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIDATA_SMPTE29BASE">MIDIDATA_SMPTE29BASE (=29)</A></TD>
  <TD>SMPTE base 29.97 frames / sec</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIDATA_SMPTE30BASE">MIDIDATA_SMPTE30BASE (=30)</A></TD>
  <TD>SMPTE base 30 frames / sec</TD>
 </TR>
</TABLE>

<P> You can get MIDIData's time mode by using <A HREF="#MIDIData_GetTimeMode">MIDIData_GetTimeMode</A> function, and you can get MIDIData's time resolution by using <A HREF="#MIDIData_GetTimeResolution">MIDIData_GetTimeResolution</A> function. Also you can get MIDIData's TimeBase by using <A HREF="#MIDIData_GetTimeBase">MIDIData_GetTimeBase</A> function. You can convert MIDIData's TimeBase by using <A HREF="#MIDIData_SetTimeBase">MIDIData_SetTimeBase</A> function. Be careful converting TimeBase may cause loss of time accuracy.</P>


<H3><A NAME="MIDIData_CreateFunction">2-4. Create MIDIData</A></H3>

<P> You can create new MIDIData on the memory by using MIDIData_Create funcition.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_CreateFunctionList">▼List2-4. How to use MIDIData_Create functions</A></DIV>
<PRE>
	MIDIData* pMIDIData;
	<SPAN CLASS="COMMENT">/* Create new MIDIData on the memory (Format1, NumTracks=6, TPQNBase, Resolution=120/Quarter-note) */</SPAN>
	pMIDIData = MIDIData_Create (MIDIDATA_FORMAT1, 6, MIDIDATA_TPQNBASE, 120);
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDIData == NULL) {
		<SPAN CLASS="COMMENT">/* Failed */</SPAN>
		printf (<SPAN CLASS="STRING">"MIDIData_Create Failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Successful */</SPAN>
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_CreateFunctionTable">▼Table2-4. Table of MIDIData_Create functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_Create">MIDIData* MIDIData_Create <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lFormat, <SPAN CLASS="KEYWORD">long</SPAN> lNumTrack, <SPAN CLASS="KEYWORD">long</SPAN> lTimeMode, <SPAN CLASS="KEYWORD">long</SPAN> lTimeResolution);</A> </TD>
  <TD>lFormat : format (<A HREF="#MIDIData_Format0">MIDIDATA_FORMAT0</A>, <A HREF="#MIDIData_Format1">MIDIDATA_FORMAT1</A>, or <A HREF="#MIDIData_Format2">MIDIDATA_FORMAT2</A>)<BR>lNumTrack : Number of tracks (0〜65535)<BR>lTimeMode : Time mode(<A HREF="#MIDIDATA_TPQNBASE">MIDIDATA_TPQNBASE</A>, <A HREF="#MIDIDATA_SMPTE24BASE">MIDIDATA_SMPTE24BASE</A>, <A HREF="#MIDIDATA_SMPTE25BASE">MIDIDATA_SMPTE25BASE</A>, <A HREF="#MIDIDATA_SMPTE29BASE">MIDIDATA_SMPTE29BASE</A>, <A HREF="#MIDIDATA_SMPTE30BASE">MIDIDATA_SMPTE30BASE</A>)<BR>lTimeResolution : Time resolution [ticks per quarter note] or [subframes per frame]</TD>
  <TD>Successful:A pointer to the MIDIData<BR>Failed : NULL</TD>
  <TD>Create new MIDIData on the memory. New MIDIData contains specified number of tracks. Each track has no events. Programmers must insert essential event to the track, such as <A HREF="#MIDIEvent_EndofTrack">end of track</A> event. If <A HREF="#MIDIData_Format0">format0</A>, lNumTrack must be 1<BR> If time mode is TPQN base, <A HREF="#MIDIData_TimeBase">time resolution</A> must be between MIDIDATA_MINTPQNRESOLUTION(=1) and MIDIDATA_MAXTPQNRESOLUTION(=32767). If time mode is SMPTE base, time resolution must be between MIDIDATA_MINSMPTERESOLUTION(=1) and MIDIDATA_MAXSMPTERESOLUTION(=255).</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_DeleteFunction">2-5. Delete MIDIData</A></H3>

<P> You can delete MIDIData on the memory by using MIDIData_Delete funcition. You must at last delete MIDIData which is created by MIDIData_Create or MIDIData_Load function, and set pointer NULL.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_DeleteFunctionList">▼List2-5. How to use MIDIData_Delete Functions</A></DIV>
<PRE>
	MIDIData_Delete (pMIDIData);
	pMIDIData = NULL;
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_DeleteFunctionTable">▼Table2-5. Table of MIDIData_Delete functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_Delete"><SPAN CLASS="KEYWORD">void</SPAN> MIDIData_Delete <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData.</TD>
  <TD>Nothing</TD>
  <TD>Delete MIDIData. <SPAN CLASS="RED">This function delete all MIDITrack and all MIDIEvent containing in the MIDIData.</SPAN></TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_LoadFunction">2-6. Load MIDIData</A></H3>

<P> MIDIDataLibaray can load Sekaiju sequence file (*.skj), Cherry sequence file (*.chy), standard MIDI file (*.mid), and MIDICSV file (*.csv).</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_LoadFunctionList">▼List2-6. How to use MIDIData_Load functions</A></DIV>
<PRE>
	MIDIData* pMIDIData;
	MIDITrack* pMIDITrack;
	MIDIEvent* pMIDIEvent;
	<SPAN CLASS="COMMENT">/* Load from standard  MIDI file (*.mid) */</SPAN>
	pMIDIData = MIDIData_LoadFromSMF (<SPAN CLASS="STRING">"c:\\my documents\\test1.mid"</SPAN>);
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDIData == NULL) {
		<SPAN CLASS="COMMENT">/* Failed */</SPAN>
		printf (<SPAN CLASS="STRING">"MIDIData_LoadFromSMF failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Chain note on and note off */</SPAN>
	forEachTrack (pMIDIData, pMIDITrack) {
		forEachEvent (pMIDITrack, pMIDIEvent) {
			<SPAN CLASS="KEYWORD">if</SPAN> (MIDIEvent_IsNoteOn (pMIDIEvent)) {
				MIDIEvent_Combine (pMIDIEvent);
			}
		}
	}
	....
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_LoadFunctionTable">▼Table2-6. Table of MIDIData_Load functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_LoadFromBinary">MIDIData* MIDIData_LoadFromBinary <BR>(<SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : Pointer to MIDIData<BR>Failed : NULL</TD>
  <TD>Load MIDIData from Sekaiju Sequence file (*.skj). This function load all information including user area. This function load all kind of events. This function automatically restore each event's combination status such as note on and note off.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_LoadFromSMF">MIDIData* MIDIData_LoadFromSMF <BR>(<SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : Pointer to MIDIData<BR>Failed : NULL</TD>
  <TD>Load MIDIData from standard MIDI file (*,mid). This function load all kind of events. This function can't load each event's combination status such as note on and note off. So after loading, you should combine note on and note off by using <A HREF="#MIDIEvent_Combine">MIDIEvent_Combine</A> function. Each track's input and output is initialized to on. Each track's input port and output port is initialized to port number defined by port prefix event in the track. If has no port prefix event, initialized to 0. Each track's input channel and output channel is initialized to conatining MIDIEvent's channel in the track. If has no MIDI channel event or has multiple channel event, intialized to n/a. Each track's view mode (normal or drum) is automatically detected. This function can load XF data (YAMAHA's extended format). This function can load concealed track.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_LoadFromCherry">MIDIData* MIDIData_LoadFromCherry <BR>(<SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : Pointer to MIDIData<BR>Failed : NULL</TD>
  <TD>Load MIDIData from Cherry sequence file (*.chy). This function automatically restore each event's combination status such as note on and note off. Each track's input and output is initialized to on. Each track's input port and output port is restored. Each track's input channel and output channel is restored. Each track's viewmode is retored. Cherry sequence's rhythm pattern can't be loaded.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_LoadFromMIDICSV">MIDIData* MIDIData_LoadFromMIDICSV <BR>(<SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : Pointer to MIDIData<BR>Failed : NULL</TD>
  <TD>Load MIDIData from MIDICSV file (*.csv). This function's specification is same as MIDIData_LoadFromSMF. This function can NOT load XF data (YAMAHA's extended format)'s extended track.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_LoadFromWRK">MIDIData* MIDIData_LoadFromWRK<BR>(<SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : Pointer to MIDIData<BR>Failed : NULL</TD>
  <TD>Load MIDIData from early cakewalk sequence file (*.wrk). This functin only load items reralted to Standard MIDI file. But each track's output port and output channel can be loaded. This function automatically restore each event's combination status such as note on and note off. Wrk file is proprietary format, so analyzing is difficult, so this function may not works completely, but this function load events as possible. File version 2.0 (generated by Cakewalk3.x) and version 3.0 (generated by Cakewalk5.x) can be load well.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_LoadFromMabiMML">MIDIData* MIDIData_LoadFromMabiMML<BR>(<SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : Pointer to MIDIData<BR>Failed : NULL</TD>
  <TD>Load MIDIData from Mabinogi MML file (*.mmml). Mabinogi MML File must be ANSI text file, and the text must be one channel format like "t95v14l16o4eg#ab&gt;c4&amp;c8&lt;a4.gb&gt;cdd4e8&lt;b4." or multi channel format like "MML@[ch1],[ch2],[ch3];".</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_SaveFunction">2-7. Save MIDIData</A></H3>

<P> MIDIDataLibrary can save MIDIData as Sekaiju sequence file (*.skj), Cherry sequence file (*.chy), standard MIDI file (*.mid), and MIDICSV file (*.csv).</P>

<P>　<SPAN CLASS="RED">When saving, each track MUST has <A HREF="#MIDIEvent_EndofTrack">end of track</A> event at the track's end. If MIDIData is  <A HREF="#MIDIData_Format1">format1</A>, because the first track is conductor track, the first track MUST NOT contain <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A>. and the second or following track MUST NOT contain <A HREF="#MIDIEvent_Tempo">tempo</A>, <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A>, <A HREF="#MIDIEvent_TimeSignature">time Signature</A>, and <A HREF="#MIDIEvent_KeySignature">key Signature</A> event. MIDIDataLibrary doesn't check them when saving, so programmer must check them.</SPAN></P>
 
<DIV CLASS="TITLE"><A NAME="MIDIData_SaveFunctionList">▼List2-7. How to use MIDIData_Save functions</A></DIV>
<PRE>
	...
	<SPAN CLASS="COMMENT">Save MIDIData as Standard MIDI file (*.mid)</SPAN>
	ret = MIDIData_SaveAsSMF (pMIDIData, <SPAN CLASS="STRING">"c:\\my documents\\test2.mid"</SPAN>);
	<SPAN CLASS="KEYWORD">if</SPAN> (ret == 0) {
		<SPAN CLASS="COMMENT">/* Failed */</SPAN>
		printf (<SPAN CLASS="STRING">"MIDIData_SaveAsSMF failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Successful */</SPAN>
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_SaveFunctionTable">▼Table2-8. Table of MIDIData_Save functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SaveAsBinary"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SaveAsBinary <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Save MIDIData as Sekaiju sequence file (*.skj). This function can save all property of MIDITrack. This function can save all kind of event. This function can save each event's combination status such as note on and note off.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SaveAsSMF"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SaveAsSMF <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Save MIDIData as standard MIDI file (*.mid). This function can save all kind of event. This function can NOT save each MIDITrack's property (input on, input port, input channel, output on, output port, output channel, view mode and so on). This function can NOT save each event's combination status such as note on and note off. This function can save XF data (Yamaha's extended format).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SaveAsCherry"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SaveAsCherry <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Save MIDIData as Cherry sequence file (*.chy). This function can NOT save each MIDITrack's input on, input port, input channel, output on, forecolor, and backcolor. This function can save each MIDITrack's output port, output channel, time+, key+, velocity+. This function can save each event's combination status such as note on and note off. This function can save ONLY note on, note off, control change, program change, system exclusive, tempo, text, lyrics, end of track, time signature, key signature event. This function can save ONLY the first sequence name and copyright notice event. The other event is not saved.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SaveAsMIDICSV"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SaveAsMIDICSV <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszFileName);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pszFileName : Pointer to null terminated file name</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Save MIDIData as MIDICSV file (*.csv). This function's specification is same as MIDIData_SaveAsSMF. If XF data (YAMAHA's extended format), this function can NOT save extended track.</TD>
 </TR>
</TABLE>


<H3><A NAME="MIDIData_InsertTrackFunction">2-8. Insert MIDITrack to MIDIData</A></H3>

<P> You can insert MIDITrack to MIDIData by using MIDIData_InsertTrack function.</P>

<P> MIDIDataLibrary can insert unlimited MIDITracks, but be careful standard MIDI file (*.mid) can save only 65535 tracks. In format0, MIDIData can have only single track.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_InsertTrackFunctionList">▼List2-8. How to use MIDITrack_Insert function</A></DIV>
<PRE>
	...
	pMIDIData = MIDIData_Create (MIDIDATA_FORMAT1, 6, MIDIDATA_TPQNBASE, 120);
	...
	<SPAN CLASS="COMMENT">/* Create new MIDITrack */</SPAN>
	pMIDITrack = MIDITrack_Create ();
	...
	<SPAN CLASS="COMMENT">/* Insert the MIDITrack at the end MIDIData */</SPAN>
	MIDIData_InsertTrackAfter (pMIDIData, pMIDITrack, pMIDIData-&gt;m_pLastTrack);
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_InsertTrackFunctionTable">▼Table2-8. Table of MIDIData_InsertTrack functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_InsertTrackBefore"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_InsertTrackBefore <BR>(MIDIData* pMIDIData, MIDITrack* pMIDITrack, MIDITrack* pTarget);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pMIDITrack : Pointertto MIDITrack<BR>pTarget : Pointer to target track</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Insert MIDITrack before pTarget track. pMIDITrack must be floating status. If pTarget is NULL, pMIDITrack is inserted at the last of the list. pTarget must belong to pMIDIData. This function does not validate the track. If <A HREF="#MIDIData_Format1">format1</A>, you must not insert track before the conductor track and you must not insert conductor track after the conductor track. If <A HREF="#MIDIData_Format0">format0</A>, MIDIData can have only single MIDITrack, so you can't add any more. But if XF data (YAMAHA's extended format) MIDIData can have three MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_InsertTrackAfter"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_InsertTrackAfter <BR>(MIDIData* pMIDIData, MIDITrack* pMIDITrack, MIDITrack* pTarget);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pMIDITrack : Pointer to MIDITrack<BR>pTarget : Pointer to target track</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Insert MIDITrack after pTarget track. pMIDITrack must be floating status. If pTarget is NULL, pMIDITrack is inserted at the first of the list. pTarget must belong to pMIDIData. This function does not validate the track. If <A HREF="#MIDIData_Format1">format1</A>, you must not insert track before the conductor track and you must not insert conductor track after the conductor track. If <A HREF="#MIDIData_Format0">format0</A>, MIDIData can have only single MIDITrack, so you can't add any more. But if XF data (YAMAHA's extended format) MIDIData can have three MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_AddTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_AddTrack <BR>(MIDIData* pMIDIData, MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Insert MIDITrack at the last of list. This function is same as MIDITrack_InsertTrackBefore (pMIDIData, pMIDITrak, NULL).</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_RemoveTrackFunction">2-9. Remove MIDITrack from MIDIData.</A></H3>

<P> You can remove MIDITrack from MIDIData by using MIDIData_RemoveTrack function. This function removes MIDITrack, but NOT delete MIDITrack on the memory. If you need to delete MIDITrack, You should use <A HREF="#MIDITrack_Delete">MIDITrack_Delete</A> function.</P>

<P> <SPAN CLASS="RED">If format1, be careful not to remove the conductor track. If you removed the conductor track, you must insert new conductor track immediately.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_RemoveTrackFunctionList">▼List2-9. How to use MIDIData_RemoveTrack function</A></DIV>
<PRE>
	<SPAN CLASS="COMMENT">/* Remove last MIDITrack */</SPAN>
	MIDIData_RemoveTrack (pMIDIData, pMIDIData-&gt;m_pLastTrack);
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_RemoveTrackFunctionTable">▼Table2-9. Table of MIDIData_RemoveTrack functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_RemoveTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_RemoveTrack<BR>(MIDIData* pMIDIData, MIDITrack* pMIDITrack)</A></TD>
  <TD>pMIDIData : pointer to MIDIData<BR>pMIDITrack : pointer to MIDITrack</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Remove MIDITrack from MIDIData. This function does NOT delete MIDITrack on the memory. </TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_GetFunction">2-10. Get MIDIData's property</A></H3>

<P> You can get MIDIData's property by using MIDIData_Get functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_GetFunctionList">▼List2-10. How to use MIDIData_Get functions</A></DIV>
<PRE>
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDIData* pMIDIData;
	<SPAN CLASS="COMMENT">/* Load MIDIData */</SPAN>
	pMIDIData = MIDIData_LoadFromSMF (<SPAN CLASS="STRING">"c:\\my document\\e.mid"</SPAN>);
	...
	<SPAN CLASS="COMMENT">/* Output MIDIData's property */</SPAN>
	printf (<SPAN CLASS="STRING">"Format = %d\n"</SPAN>, MIDIData_GetFormat (pMIDIData));
	printf (<SPAN CLASS="STRING">"Number of Tracks = %d\n"</SPAN>, MIDIData_GetNumTrack (pMIDIData));
	printf (<SPAN CLASS="STRING">"Time mode = %d\n"</SPAN>, MIDIData_GetTimeMode (pMIDIData));
	printf (<SPAN CLASS="STRING">"Resolution = %d\n"</SPAN>, MIDIData_GetResolution (pMIDIData));
	printf (<SPAN CLASS="STRING">"The first event's time = %d\n"</SPAN>, MIDIData_GetBeginTime (pMIDIData));
	printf (<SPAN CLASS="STRING">"The last event's time = %d\n"</SPAN>, MIDIData_GetEndTime (pMIDIData));
	printf (<SPAN CLASS="STRING">"Title = \"%s\"\n"</SPAN>, MIDIData_GetTitle (pMIDIData, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
	printf (<SPAN CLASS="STRING">"Copyright = \"%s\"\n"</SPAN>, MIDIData_GetCopyright (pMIDIData, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
	printf (<SPAN CLASS="STRING">"Comment = \"%s\"\n"</SPAN>, MIDIData_GetComment (pMIDIData, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_GetFunctionTable">▼Table2-10. Table of MIDIData_Get functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetFormat"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetFormat <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : pointer to MIDIData</TD>
  <TD>MIDIData's format(0〜2)</TD>
  <TD>Get MIDIData's <A HREF="#MIDIData_Format">format</A>. Format can be <A HREF="#MIDIData_Format0">MIDIDATA_FORMAT0(=0)</A>, <A HREF="#MIDIData_Format1">MIDIDATA_FORMAT1(=1)</A>, or <A HREF="#MIDIData_Format2">MIDIDATA_FORMAT2(=2)</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetNumTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetNumTrack <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : pointer to MIDIData</TD>
  <TD>Number of MIDITracks</TD>
  <TD>Get number of MIDITracks. Be careful this value is updated only when MIDIData_CountTrack is used (include internal counting).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetTimeMode"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetTimeMode <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : pointer to MIDIData</TD>
  <TD>MIDIData's time mode</TD>
  <TD>Get MIDIData's <A HREF="#MIDIData_TimeBase">time mode</A>. Time mode can be <A HREF="#MIDIDATA_TPQNBASE">MIDIDATA_TPQNBASE(=0)</A>, <A HREF="#MIDIDATA_SMPTE24BASE">MIDIDATA_SMPTE24BASE(=24)</A>, <A HREF="#MIDIDATA_SMPTE25BASE">MIDIDATA_SMPTE25BASE(=25)</A>, <A HREF="#MIDIDATA_SMPTE29BASE">MIDIDATA_SMPTE29BASE(=29)</A>, or <A HREF="#MIDIDATA_SMPTE30BASE">MIDIDATA_SMPTE30BASE(=30)</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetTimeResolution"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetTimeResolution <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : pointer to MIDIData</TD>
  <TD>MIDIData's time resolution</TD>
  <TD>Get MIDIData's <A HREF="#MIDIData_TimeBase">time resolution</A>. If time mode is MIDIDATA_TQPNBASE(=0), time resolution can be between MIDIDATA_MINTPQNRESOLUTION(=1) and MIDIDATA_MAXTPQNRESOLUTION(=32767). Else, time resolution can be between MIDIDATA_MINSMPTERESOLUTION(=1) and MIDIDATA_MAXSMPTERESOLUTION(=255).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetTimeBase"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetTimeBase <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN>* pMode, <SPAN CLASS="KEYWORD">long</SPAN>* pResolution);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIdata<BR>pMode : Pointer to buffer for write time mode.<BR>pResolution : Pointer to buffer for write resolution.</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Get MIDIData's <A HREF="#MIDIData_TimeBase">time base</A>, that is, both time mode and resolution. The value is same as described in <A HREF="#MIDIData_GetTimeMode">MIDIData_GetTimeMode</A> and <A HREF="#MIDIData_GetTimeResolution">MIDIData_GetTimeResolution</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetTitle">TCHAR* MIDIData_GetTitle <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">TCHAR</SPAN>* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pBuf : Pointer to buffer for write title<BR>lLen : Max text length [_tchar]</TD>
  <TD>pBuf</TD>
  <TD>Get MIDIData's the first track's the first <A HREF="#MIDIEvent_TrackName">track name</A> event's text.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetCopyright">TCHAR* MIDIData_GetCopyright <BR>(MIDIData* pMIDIData, TCHAR* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pBuf : Pointer to buffer for write copyright<BR>lLen : Max text length [_tchar]</TD>
  <TD>pBuf</TD>
  <TD>Get MIDIData's the first track's the first <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event's text.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetComment">TCHAR* MIDIData_GetComment <BR>(MIDIData* pMIDIData, TCHAR* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pBuf : Pointer to buffer for write comment<BR>lLen : Max text length [_tchar]</TD>
  <TD>pBuf</TD>
  <TD>Get MIDIData's the first track's the first <A HREF="#MIDIEvent_TextEvent">text</A> event's text.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetFirstTrack">MIDITrack* MIDIData_GetFirstTrack <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData</TD>
  <TD>Pointer to the first MIDITrack</TD>
  <TD>If has no track, it returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetLastTrack">MIDITrack* MIDIData_GetLastTrack <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData</TD>
  <TD>Pointer to the last MIDITrack</TD>
  <TD>If has no track, it returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetTrack">MIDITrack* MIDIData_GetTrack <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTrackIndex);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTrackIndex : Track index(0〜)</TD>
  <TD>Pointer to the specified MIDITrack</TD>
  <TD>If not found, it returns NULL. This function is very slow, so not recommmended.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetBeginTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetBeginTime <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData</TD>
  <TD>Begin time</TD>
  <TD>Get the first <A HREF="#MIDIEvent">MIDIEvent</A>'s time.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetEndTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetEndTime <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData</TD>
  <TD>End time</TD>
  <TD>Get the last <A HREF="#MIDIEvent">MIDIEvent's</A> time.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_GetXFVersion"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_GetXFVersion <BR>(MIDIData* pMIDIData);</A> </TD>
  <TD>pMIDIData : Pointer to MIDIData</TD>
  <TD>XF data's version.</TD>
  <TD>If the MIDIData is XF data (YAMAHA's extended format), catch the sequencer specific event {43 7B 00 58 46 Mj Mn S1 S0}, and then return (Mj | (Mn &lt;&lt; 8) | (S1 &lt;&lt; 16) | (S0 &lt;&lt; 24))'s value.  If not XF data, it returns 0.</TD>
 </TR>
</TABLE>


<H3><A NAME="MIDIData_SetFunction">2-11. Set MIDIData's property</A></H3>
<P> You can set MIDIData's property by using MIDIData_Set functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_SetFunctionList">▼List2-11. How to use MIDIData_Set系 functions</A></DIV>
<PRE>
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDIData* pMIDIData;
	<SPAN CLASS="COMMENT">/* Load MIDIData from standard MIDI file(*.mid) */</SPAN>
	pMIDIData = MIDIData_LoadFromSMF (<SPAN CLASS="STRING">"c:\\my document\\e.mid"</SPAN>);
	...
	<SPAN CLASS="COMMENT">/* Set MIDIData's property. */</SPAN>
	MIDIData_SetTitle (pMIDIData, <SPAN CLASS="STRING">"Guruguru kazan"</SPAN>, 14);
	MIDIData_SetCopypright (pMIDIData, <SPAN CLASS="STRING">"(C)2112 Armi"</SPAN>, 12);
	MIDIData_SetComment (pMIDIData, <SPAN CLASS="STRING">"Sound module ：Poland SC-88Ero"</SPAN>, 29);
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_SetFunctionTable">▼Table2-11. Table of MIDIData_Set functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Descriptiion</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SetFormat"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SetFormat <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lFormat);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lFormat : MIDIData's new format(<A HREF="#MIDIData_Format0">MIDIDATA_FORMAT0</A>, <A HREF="#MIDIData_Format1">MIDIDATA_FORMAT1</A>, or<A HREF="#MIDIData_Format2">MIDIDATA_FORMAT2</A>)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Convert MIDIData's format. If you convert <SPAN CLASS="RED"><A HREF="#MIDIData_Format1">format1</A> or <A HREF="#MIDIData_Format2">format2</A> to <A HREF="#MIDIData_Format0">format0</A>, all <A HREF="#MIDIEvent">MIDIEvents</A> are gathered to one track. But in case of XF data (YAMAHA's extended format), gathered to three tracks, and text event with "XF" is moved to the second track, and lyrics and cue point events are moved to the third track. If you convert <A HREF="#MIDIData_Format0">format0</A> to <A HREF="#MIDIData_Format1">format1</A> or <A HREF="#MIDIData_Format2">format2</A>, all <A HREF="#MIDIEvent">MIDIEvent</A> are scattered to 17 tracks. <A HREF="#MIDIEvent_MetaEvent">Meta event</A> and <A HREF="#MIDIEvent_SysExEvent">system exclusive event</A> is moved to the first MIDITrack, and the other <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> are moved to the second or lator track by assigned to the each event's channnel(0〜15). But in case of XF data (YAMAHA'x extended format), scattered to 19 tracks, and text event with "XF" is moved to the 18th track, and lyrics and cue point events are moved to the 19th track. The other conversion will be failed and returns 0. Each track's input and output are initialized to on. Each track's input port and output port are initialized to port defined by port prefix event (if unknown, initialized to 0). Each track's input channel and output channel are initialized to MIDIEvent's channel containing in the track (in unknown, initialized to n/a). Each track's view mode is detected automatically.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SetTimeBase"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SetTimeBase <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTimeMode, <SPAN CLASS="KEYWORD">long</SPAN> lTimeResolution);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTimeMode : Time mode(<A HREF="#MIDIDATA_TPQNBASE">MIDIDATA_TPQNBASE</A>, <A HREF="#MIDIDATA_SMPTE24BASE">MIDIDATA_SMPTE24BASE</A>, <A HREF="#MIDIDATA_SMPTE25BASE">MIDIDATA_SMPTE25BASE</A>, <A HREF="#MIDIDATA_SMPTE29BASE">MIDIDATA_SMPTE29BASE</A>, or <A HREF="#MIDIDATA_SMPTE30BASE">MIDIDATA_SMPTE30BASE</A>)<BR>lTimeResolution : Time resolution [ticks per quarter note] or [subframes per frame]</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Convert MIDIData's time mode and time resolution. <SPAN CLASS="RED">If time mode is TPQN base, time resolution is [ticks per quarter note], and the value must be between MIDIDATA_MINTPQNRESOLUTION(1) and MIDIDATA_MAXTPQNRESOLUTION(32767). If time mode is SMPTE base, time resolution is [subframes per frame], and the value must be between MIDIDATA_MINSMPTERESOLUTION(1) and MIDIDATA_MAXSMPTERESOLUTION(255).</SPAN><BR>
<SPAN CLASS="RED">When convertiong time base, all MIDIEvent's time in the MIDIData is calucrated to keep the playing timing. If you convert to lower resolution, the time accuracy will be lost. If you convert TPQN base to SMPTE base, or SMPTE base to TPQN base, positive 1 or negative 1's caluclation error may be occur.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SetTitle"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SetTitle <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pszText : Pointer to zero terminated string</TD>
  <TD>Undefined</TD>
  <TD>Set MIDIData's the first <A HREF="#MIDITrack">track</A>'s the first <A HREF="#MIDIEvent_TrackName">track name</A> event's text. If the first track has no track name event, automatically added. If pszText is NULL, the first track's track name event is deleted.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SetCopyright"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SetCopyright <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDIData: Pointer to MIDIData<BR>pszText : Pointer to zero terminated string</TD>
  <TD>Undefined</TD>
  <TD>Set MIDIData's the first <A HREF="#MIDITrack">track</A>'s the first <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event's text. If the first track has no copyright notice event, automatically added. If pszText is NULL, the first track's first copyright notice event is deleted.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_SetComment"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_SetComment <BR>(MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>pszText : Pointer to zero terminated string.</TD>
  <TD>Undefined</TD>
  <TD>Set MIDIData's the first <A HREF="#MIDITrack">track</A>'s the first<A HREF="#MIDIEvent_TextEvent">text</A>  event's text. If the first track has no text event, automatically added. If pszText is NULL, the first track's the first text event is deleted.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_OtherFunction">2-12. MIDIData's other functions</A></H3>

<DIV CLASS="TITLE"><A NAME="MIDIData_OtherFunctionTable">▼Table2-12. Table of MIDIData_Other functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_CountTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_CountTrack (MIDIData* pMIDIData);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData</TD>
  <TD>Number of MIDITrack</TD>
  <TD>Count up number of MIDITrack and update the <A HREF="#MIDIData_FieldTable">m_lNumTrack</A> field.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_TimeToMillisec"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_TimeToMillisec (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTime);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTime : time [ticks] or [subframes]</TD>
  <TD>[millisec]</TD>
  <TD>Convert time code [tick] or [subframes] to [millisec]. This function calculate by using only the first track's <A HREF="#MIDIEvent_Tempo">tempo</A> events.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_MillisecToTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_MillisecToTime (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lMillisec);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lMillisec : [millisec]</TD>
  <TD>Time code [ticks] or [subframes]</TD>
  <TD>Convert [millisec] to time [tick] or [subframes]. This function calculate by using only the first track's <A HREF="#MIDIEvent_Tempo">tempo</A> events.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_MakeTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_MakeTime (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lMeasure, <SPAN CLASS="KEYWORD">long</SPAN> lBeat, <SPAN CLASS="KEYWORD">long</SPAN> lTick, <SPAN CLASS="KEYWORD">long</SPAN>* pTime);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lMeasure : Measure number (0〜)<BR>lBeat : Beat number (0〜)<BR>lTick : Tick number (0〜)<BR>pTime : Pointer to buffer for write absolute time [ticks]</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>If TPQN base, convert [measure : beat : tick] to absolute time [ticks]. This function calculate by using only the first track's <A HREF="#MIDIEvent_TimeSignature">time signature</A> events. If SMPTE base, convert [frame : subframe] to absolute time [subframes]. In this case, specify frame in lMeasure, subframe in lTick.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_MakeTimeEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_MakeTimeEx (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lMeasure, <SPAN CLASS="KEYWORD">long</SPAN> lBeat, <SPAN CLASS="KEYWORD">long</SPAN> lTick, <SPAN CLASS="KEYWORD">long</SPAN>* pTime, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lMeasure : Measure number (0〜)<BR>lBeat : Beat number (0〜)<BR>lTick : Tick number (0〜)<BR>pTime : Pointer to buffer for write absolute time.<BR>pnn：Pointer to buffer for write numerator<BR>pdd : Pointer to buffer for write denominator's power<BR>pcc : Pointer to buffer for write clocks per quarter note<BR>pbb : Pointer to buffer for write demisemiquarver per quarter note</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>This function is same as <A HREF="#MIDIData_MakeTime">MIDIData_MakeTime</A>, but additionally get nearest <A HREF="#MIDIEvent_TimeSignature">time signature</A> event's property. But if SMPTE base, you may not get time signature's property.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_BreakTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_BreakTime (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pMeasure, <SPAN CLASS="KEYWORD">long</SPAN>* pBeat, <SPAN CLASS="KEYWORD">long</SPAN>* pTick);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTime : Absolute Time [ticks]<BR>pMeasure : Pointer to buffer for write measure number (0〜)<BR>pBeat : Pointer to buffer for write beat number (0〜)<BR>pTick : Pointer to buffer to write tick number (0〜)</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>If TPQN base, convert absolute time [ticks] to [measure : beat : tick]. This function calculate by using only the first track's <A HREF="#MIDIEvent_TimeSignature">time signature</A> events. If SMPTE base, convert absolute time [subframes] to [frame : subframe]. In this case, frame is written in pMeasure, and subframe is written in pTick.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_BreakTimeEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_BreakTimeEx (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pMeasure, <SPAN CLASS="KEYWORD">long</SPAN>* pBeat, <SPAN CLASS="KEYWORD">long</SPAN>* pTick, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTime : Absolute Time [ticks]<BR>pMeasure : Pointer to buffer for write measure number (0〜)<BR>pBeat : Pointer to buffer for write beat number (0〜)<BR>pTick : Pointer to buffer to write tick number (0〜)<BR>pnn：Pointer to buffer for write  numerator<BR>pdd : Pointer to buffer for write denominator's power<BR>pcc : Pointer to buffer for write clocks per quarter note<BR>pbb : Pointer to buffer for write demisemiquarver per quarter note</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>This function is same as <A HREF="#MIDIData_BreakTime">MIDIData_BreakTime</A>, but additionally get nearest <A HREF="#MIDIEvent_TimeSignature">time signature</A> event's property. But if SMPTE base, you may not get time signature event's property.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_FindTempo"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_FindTempo (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pTempo);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTime : Absolute time [ticks]<BR>pTempo : Pointer to Buffer for write tempo.</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Get nearest tempo event's tempo at lTime. This function search only the first track's <A HREF="#MIDIEvent_Tempo">tempo</A> events. <SPAN CLASS="RED">Be careful that tempo's unit is [microsec / quarter note]. If tempo event is not found, returns 500000 [microsec / quarter note] as default tempo.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_FindTimeSignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_FindTimeSignature (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTime : Absolute time [ticks]<BR>pnn : Pointer to buffer for write numerator<BR>pdd : Pointer to buffer for write denominator's power<BR>pcc : Pointer to buffer for write clocks per quarter note<BR>pbb : Pointer to buffer for write demisemiquarver per quarter note.</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Get Nearest time signature event's property at lTime. This function searches only the first track's <A HREF="#MIDIEvent_TimeSignature">time signature</A> event. If time signature event is not found, returns 4/4, 24[clocks / quarter note], 8[demisemiquarver / quarter note] as default.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIData_FindKeySignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIData_FindKeySignature (MIDIData* pMIDIData, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* psf, <SPAN CLASS="KEYWORD">long</SPAN>* pmi);</A></TD>
  <TD>pMIDIData : Pointer to MIDIData<BR>lTime : Absolute time [ticks]<BR>psf : Pointer to buffer for write number of # or ♭.<BR>pmi : Pointer to buffer to write major or minor</TD>
  <TD>Successful ： non 0<BR>Failed ： 0</TD>
  <TD>Get nearest key signature event's property at lTime. This function searches only the first track's <A HREF="#MIDIEvent_KeySignature">key signature</A> event. If psf is positive, it means number of #, if psf is negative, it means number of ♭, and if psf is 0, it means non # or ♭. If pmi MIDIEVENT_KEYMAJOR(0), it means major, and if pmi is MIDIEVENT_KEYMINOR(1), it means minor.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIData_forEachTrack">2-13. forEachTrack</A></H3>

<P> In order to access each MIDITrack in the MIDIData, you can use forEachTrack or forEachTrackInverse macro.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_forEachTrackList1">▼List2-13-1. How to use forEachTrack macro</A></DIV>
<PRE>
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDIData* pMIDIData;
	MIDITrack* pMIDITrack;
	...
	<SPAN CLASS="COMMENT">/* Print each MIDITrack's name in the MIDIData */</SPAN>
	forEachTrack (pMIDIData, pMIDITrack) {
		printf (<SPAN CLASS="STRING">"Track name : %s\n"</SPAN>, MIDITrack_GetName (pMIDITrack, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
	}
</PRE>

<P> Following program is just same as above program.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_forEachTrackList2">▼List2-13-2. Just same as above program</A></DIV>
<PRE>
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDIData* pMIDIData;
	MIDITrack* pMIDITrack;
	...
	<SPAN CLASS="COMMENT">/* Print each MIDITrack's name in the MIDIData */</SPAN>
	pMIDITrack = pMIDIData-&gt;m_pFirstData;
	<SPAN CLASS="KEYWORD">while</SPAN> (pMIDITrack) {
		printf (<SPAN CLASS="STRING">"Track name : %s\n"</SPAN>, MIDITrack_GetName (pMIDITrack, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
		pMIDITrack = pMIDITrack-&gt;m_pNextTrack;
	}
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_forEachTrackTable">▼Table2-13. Table of forEachTrack macros</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="40%">Syntax</TH>
  <TH WIDTH="60%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="forEachTrack"></A>forEachTrack (pMIDIData, pMIDITrack) {<BR>	...<BR>}</TD>
  <TD>Evaluate each MIDITrack in the MIDIData from ahead to tail.</TD>
 </TR>
 <TR>
  <TD><A NAME="forEachInverse"></A>forEachTrackInverse (pMIDIData, pMIDITrack) {<BR>	...<BR>}</TD>
  <TD>Evaluate each MIDITrack in the MIDIData from tail to ahead.</TD>
 </TR>
</TABLE>

<P> <SPAN CLASS="RED">Be careful not to insert or add MIDITrack in the forEachTrack scope. It may cause making infinite loop. If need, you should copy each MIDITrack's pointer to your local array at first, and then insert or add MIDITrack by using copied pointer.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_forEachTrackList3">▼List2-13-3. Bad program</A></DIV>
<PRE>
	...
	forEachTrack (pMIDIData, pMIDITrack) {
		MIDITrack* pNewTrack = MIDITrack_Create ();
		MIDIData_InsertTrackAfter (pMIDIData, pNewTrack, pMIDITrack);
	}
</PRE>

<P> <SPAN CLASS="RED">Be careful not remove or delete MIDITrack in the forEachTrack scope. It may cause null pointer error. If need, you should copy each MIDITrack's pointer to your local array at first, and then remove or delete MIDITrack by using copied pointer.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDIData_forEachTrackList6">▼List2-12-6. Bad program</A></DIV>
<PRE>
	...
	forEachTrack (pMIDIData, pMIDITrack) {
		MIDITrack_Delete (pMIDITrack);
	}
</PRE>

<P></P>



<H2><A NAME="MIDITrack">Chapter3 : MIDITrack</A></H2>

<H3><A NAME="MIDITrack_Struct">3-1. Structure of MIDITrack</A></H3>

<P> MIDITrack is a child of MIDIData. MIDITrack can have several <A HREF="#MIDIEvent">MIDIEvent</A> in itself. MIDIEvents in the MIDITrack is always sorted in the time order. The first event of MIDITrack should be <A HREF="#MIDIEvent_TrackName">track name</A> event. The last event of MIDITrack MUST BE <A HREF="#MIDIEvent_EndofTrack">end of track</A> event.</P>

<P> If <A HREF="#MIDIData_FormatTable">format0</A> or <A HREF="#MIDIData_FormatTable">format2</A>'s MIDIData, each MIDITrack can have all kind of <A HREF="#MIDIEvent">MIDIEvent</A>. If <A HREF="#MIDIData_FormatTable">format1</A>'s MIDIData, the first track, which is called <A HREF="#MIDITrack_SetupTrack">"Conductor Track"</A>, can has <A HREF="#MIDIEvent_Marker">marker</A>, <A HREF="#MIDIEvent_CuePoint">cue point</A>, <A HREF="#MIDIEvent_Tempo">tempo</A>, <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A>, <A HREF="#MIDIEvent_TimeSignature">time signature</A>, <A HREF="#MIDIEvent_KeySignature">key signature</A> event and so on but MUST NOT has MIDI channel event. <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> such as note on must be placed in the second or following MIDITrack. And one track can only has one channel's event.</P>

<P> MIDITrack is stored as link list so MIDITrack has the next track's pointer and previous track's pointer.</P>

<P> Here is a table of MIDITrack's field. But almost these field is sequenser specific property. Be careful that in standard MIDI file (*.mid), MIDITrack has no property.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_FieldTable">▼Table3-1.MIDIトラック構造体のメンバ変数と使い方</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Field</TH>
  <TH WIDTH="75%">Remarks</TH>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lNumEvent</TD>
  <TD>Number of MIDIEvent in this track. This value is updated only when <A HREF="#MIDITrack_CountEvent">MIDITrack_CountEvent</A> is used.</TD>
 </TR>
 <TR>
  <TD>MIDITrack* m_pNextTrack</TD>
  <TD>Pointer to the next MIDITrack. If has no next track, this value is NULL.</TD>
 </TR>
 <TR>
  <TD>MIDITrack* m_pPrevTrack</TD>
  <TD>Pointer to the previous MIDITrack. If has no previous track, this value is NULL.</TD>
 </TR>
 <TR>
  <TD>MIDIEvent* m_pFirstEvent</TD>
  <TD>Pointer to the first <A HREF="#MIDIEvent">MIDIEvent</A> in this track. If has no event, this value is NULL.</TD>
 </TR>
 <TR>
  <TD>MIDIEvent* m_pLastEvent</TD>
  <TD>Pointer to the last <A HREF="#MIDIEvent">MIDIEvent</A> in this track. If has no event, this value is NULL. Be careful it is NOT ALLOWED to omit <A HREF="#MIDIEvent_EndofTrack">end of track</A> event.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">void</SPAN>* m_pParent</TD>
  <TD>Pointer to parent <A HREF="#MIDIData">MIDIData</A>. If this track is not belongs to any MIDIData, this value is NULL.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lInputOn</TD>
  <TD>Input on (0=OFF, 1=ON). This is a sequencer specific field, so not saved to standard MIDI file(*.mid). Use only lowest 1bit. The Other bits are undefined. If supported and if the value is 1, this track's input should be muted.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lInputPort</TD>
  <TD>Input port (0〜255). This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lInputChannel</TD>
  <TD>Input channel (-1=n/a, 0〜15). This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If this value is n/a, this track should input only system exclusive event. Else, input only specified channel's event.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lOutputOn</TD>
  <TD>Output on (0=OFF, 1=ON). This is a sequencer specific field, so not saved to standard MIDI file(*.mid). Use only lowest 1bit. The other bits are undefined. If supported and if the value is 1, this track's output should be muted.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lOutputPort</TD>
  <TD>Output port (0〜255). This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lOutputChannel</TD>
  <TD>Output channel (-1=n/a, 0〜15). This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If this value is -1, each event in this track should be outputed to the each event's channel. Else, should be outputed this channel.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lTimePlus</TD>
  <TD>Time+. This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If supported, each event in this track should be outputed with specified delay.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lKeyPlus</TD>
  <TD>Key+. This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If supported, each note event in this track should be outputed with specified key shift at half pitch.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lVelocityPlus</TD>
  <TD>Velocity+。This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If supported, each note event in this track should be outputed with additional specified velocity.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lViewMode</TD>
  <TD>View mode (0=normal, 1=drum). This is a sequencer specific field, so not saved to standard MIDI file(*.mid). Use only lowest 1bit. The other bits are undefined. If supported and if this value 1, each key's name should be shown as drum mode. This is only for view, so no affect to playing.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lForeColor</TD>
  <TD>Foreground color. This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If supported, this track's foreground color should be drawn with specified color.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lBackColor</TD>
  <TD>Background color. This is a sequencer specific field, so not saved to standard MIDI file(*.mid). If supported, this track's background color should be filled with specified color.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser1</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser2</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser3</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUserFlag</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDITrack_Status">3-2. Status of MIDITrack</A></H3>

<H4><A NAME="MIDITrack_FloatTrack">Floating track</A></H4>

<P> MIDITrack which does not belongs to any MIDIData is called Floating track. If floating, m_pNextTrack is NULL, and m_pPrevTrack is NULL, and m_pParent is NULL. Floating track can't be saved to file. You can test whether floarting or not by using <A HREF="#MIDITrack_IsFloating">MIDITrack_IsFloating</A> function.</P>

<H4><A NAME="MIDITrack_SetupTrack">Conductor track</A></H4>

<P> The first track in <A HREF="#MIDIData_Format1">format1</A>'s MIDIData is called conductor track. Conductor track can contain mainly <A HREF="#MIDIEvent_Tempo">tempo</A>, <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A>, <A HREF="#MIDIEvent_TimeSignature">time signature</A>, <A HREF="#MIDIEvent_KeySignature">key signature</A> event and so on, but MUST NOT contain <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> such as note on. You can test whether conductor track is valid or not by using <A HREF="#MIDITrack_CheckSetupTrack">MIDITrack_CheckSetupTrack</A> function</P>

<H4><A NAME="MIDITrack_NonSetupTrack">Non conductor track</A></H4>

<P> The second or following tracks in <A HREF="#MIDIData_Format1">format1</A>'s MIDIData is called non conductor track. Non conductor track MUST NOT contain <A HREF="#MIDIEvent_Tempo">tempo</A>, <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A>, <A HREF="#MIDIEvent_TimeSignature">time signature</A>, <A HREF="#MIDIEvent_KeySignature">key signature</A> event. You can test whether non conductor track is valid or not by using <A HREF="#MIDITrack_CheckNonSetupTrack">MIDITrack_CheckNonSetupTrack</A> function</P>


<H3><A NAME="MIDITrack_CreateFunction">3-3. Create MIDITrack</A></H3>

<P> You can create new MIDITrack on the memory by uisng MIDITrack_Create functions. New MIDITrack contains no event, so programmer at least must add  end of track event. New MIDITrack is <A HREF="#MIDITrack_FloatingTrack">floating</A>, so programmers must insert it to MIDIData.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_CreateFunctionList">▼List3-3. How to use MIDITrack_Create functions</A></DIV>
<PRE>
	MIDITrack* pMIDITrack;
	<SPAN CLASS="COMMENT">/* Create MIDITrack */</SPAN>
	pMIDITrack = MIDITrack_Create ();
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDITrack == NULL) {
		<SPAN CLASS="COMMENT">/* Failed */</SPAN>
		printf (<SPAN CLASS="STRING">"MIDITrack_Create failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Successful */</SPAN>
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_CreateFunctionTable">▼Table3-3. Table of MIDITrack_Create functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_Create">MIDITrack* MIDITrack_Create <BR>();</A> </TD>
  <TD>None</TD>
  <TD>Successful : Pointer to MIDITrack<BR>Failed : NULL</TD>
  <TD>Create new MIDITrack on the memory. New track contains no event. At least, programmer must add <A HREF="#MIDIEvent_EndofTrack">end of track</A> event. New MIDITrack is floating.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_CreateClone">MIDITrack* MIDITrack_CreateClone <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to source track</TD>
  <TD>Successful : Pointer to MIDITrack<BR>Failed : NULL</TD>
  <TD>Duplicate MIDITrack. New track contains the same event as source track. New MIDITrack is floating.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDITrack_DeleteFunction">3-4. Delete MIDITrack</A></H3>

<P> You can delete MIDITrack by uisng MIDITrack_Delete functions.</P>

<P> <SPAN CLASS="RED">MIDITracks created by <A HREF="#MIDITrack_CreateFunction">MIDITrack_Create</A> functions must be finally deleted by MIDITrack_Delete functions. </SPAN> But in case of deleting parent MIDIData, you can omit deleting each MIDITrack in the MIDIData.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_DeleteFunctionList">▼List3-4. How to use MIDITrack_Delete functions</A></DIV>
<PRE>
	...
	<SPAN CLASS="COMMENT">/* Delete MIDITrack */</SPAN>
	MIDITrack_Delete (pMIDITrack);
	pMIDITrack = NULL;
</PRE>

<P></P>


<DIV CLASS="TITLE"><A NAME="MIDITrack_DeleteFunctionTable">▼Table3-4. Table of MIDITrack_Delete functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_Delete"><SPAN CLASS="KEYWORD">void</SPAN> MIDITrack_Delete <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>None</TD>
  <TD>Delete MIDITrack on the memory. <SPAN CLASS="RED">This function deletes all events containing in this MIDITrack. </SPAN>If MIDITrack belongs to MIDIData, link list pointer is automatically updated.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDITrack_InsertEventFunction">3-5. Insert MIDIEvent to MIDITrack</A></H3>

<P> You can insert MIDIEvent to MIDITrack by using MIDITrack_InsertEvent functions.</P>

<P> <SPAN CLASS="RED">MIDIEvent must be inserted to between time 0 and <A HREF="#MIDIEvent_EndofTrack">end of track</A> event's time. If MIDIEvent's time is over than end of track, end of track event's time is automatically modified to be the last event's time.</SPAN></P>

<P> <SPAN CLASS="RED">Insert position of the MIDIEvent is automatically determined by the MIDIEvent's time. If MIDITrack has already the same time's events, MIDIEvent is inserted the last of them. Thiese functions search inserting position from tail to ahead, so inserting at latest time is fast, but inserting at earliest time is slow. This is because designed for real-time input. </SPAN></P>

<P> <SPAN CLASS="RED">If MIDIEvent is already belonging to the other track, these function fails. In the format1's MIDIData, if MIDIEvent's kind is wrong, these function fails. Also wrong inserting such as double end of track events may fails.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_InsertFunctionList">▼List3-5. How to use MIDITrack_InsertEvent functions</A></DIV>
<PRE>
	MIDITrack* pMIDITrack = MIDITrack_Create ();
	...
	<SPAN CLASS="COMMENT">/* Insert program change event */</SPAN>
	MIDITrack_InsertProgramChange (pMIDITrack, 0, 0, 0); <SPAN CLASS="COMMENT">/* Piano1 */</SPAN>
	<SPAN CLASS="COMMENT">/* Insert note event            Time  ch  key  vel  dur */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,     0,  0,  60, 100, 120); <SPAN CLASS="COMMENT">/* C */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   120,  0,  62, 100, 120); <SPAN CLASS="COMMENT">/* D */</SPAN>
	MIDITrack_InsertNote (pMIDITrack,   240,  0,  64, 100, 240); <SPAN CLASS="COMMENT">/* E- */</SPAN>
	...
	<SPAN CLASS="COMMENT">/* Insert end of track event */</SPAN>
	MIDITrack_InsertEndofTrack (pMIDITrack, 480);
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_InsertFunctionTable">▼Table3-5. Table of MIDITrack_InsertEvent functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertEvent <BR>(MIDITrack* pMIDITrack, MIDIEvent* pMIDIEvent);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Successful : 1 or greater<BR>Failed : 0</TD>
  <TD>Insert MIDIEvent to the MIDITrack. Inserting position is automatically determined by MIDIEvent's time. If MIDITrack has the same time's event, MIDIEvent is inserted at the last of them. But note off event is inserted at after the last of note off event. If MIDIEvent is combined such as note on and note off, each event is inserted and returns the number of inserted event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertEventBefore"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertEventBefore <BR>(MIDITrack* pMIDITrack, MIDIEvent* pMIDIEvent, MIDIEvent* pTarget);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pMIDIEvent : Pointer to MIDIEvent<BR>pTarget : Pointer to target event</TD>
  <TD>Successful : 1 or greater<BR>Failed : 0</TD>
  <TD>Insert MIDIEvent before pTarget event. pTarget must belongs to the MIDITrack. If MIDIEvent's time is wrong, the time is automatically modified. This function is fast than MIDITrack_InsertEvent. If MIDIEvent is combined such as note on and note off, each event is inserted and returns the number of inserted event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertEventAfter"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertEventAfter <BR>(MIDITrack* pMIDITrack, MIDIEvent* pMIDIEvent, MIDIEvent* pTarget);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pMIDIEvent : Pointer to MIDIEvent<BR>pTarget : Pointer to target event</TD>
  <TD>Successful : 1 or greater<BR>Failed : 0</TD>
  <TD>Insert MIDIEvent after pTarget event. pTarget must belongs to the MIDITrack. If MIDIEvent's time is wrong, the time is automatically modified. This function is fast than MIDITrack_InsertEvent. If MIDIEvent is combined event such as note on and note off, each event is inserted and returns the number of inserted event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertSequenceNumber"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertSequenceNumber <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lNum : sequence number(0〜65535)</TD>
  <TD>Successful：1<BR>Failed：0</TD>
  <TD>Create new <A HREF="#MIDIEvent_SequenceNumber">sequence number</A> event and insert it to the MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertTextEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertTextEvent <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_TextEvent">text</A> event and insert it to the MIDITrack. This is the same as MIDITrack_InsertTextEventEx (pTrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertTextEventEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertTextEventEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_TextEvent">text</A> event with char code identifier and insert it to the MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest text event's char code. If text event's char code idintifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertCopyrightNotice"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertCopyrightNotice <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack: Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : A Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event and insert it to the MIDITrack. This is the same as MIDITrack_InsertCopyprightNoticeEx (pTrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertCopyrightNoticeEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertCopyrightNoticeEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event with char code identifier and insert it to the MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertTrackName"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertTrackName <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_TrackName">sequence name / track name</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertTrackNameEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertTrackNameEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertTrackNameEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_TrackName">sequence name / track name</A> event with char code identifier and insert it to the MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertInstrumentName"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertInstrumentName <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_InstrumentName">instrument name</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertInstrumentNameEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertInstrumentNameEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertInstrumentNameEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_InstrumentName">instrument name</A> with char code identifier and insert it to MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertLyric"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertLyric <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_Lyric">lyric</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertLyricEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertLyricEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertLyricEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_Lyric">lyric</A> with char code identifier and insert it to MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertMarker"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertMarker <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_Marker">marker</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertMarkerEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertMarkerEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertMarkerEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_Marker">marker</A> with char code identifier and insert it to MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertCuePoint"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertCuePoint <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_CuePoint">cue point</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertCuePointEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertCuePointEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertCuePointEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_CuePoint">cue point</A> with char code identifier and insert it to MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertProgramName"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertProgramName <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ProgramName">program name</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertProgramNameEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertProgramNameEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertProgramNameEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ProgramName">program name</A> with char code identifier and insert it to MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertDeviceName"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertDeviceName <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_DeviceName">device name</A> event and insert it to MIDITrack. This function is same as MIDITrack_InsertDeviceNameEx (pMIDITrack, lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertDeviceNameEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertDeviceNameEx <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, or MIDIEVENT_UTF16BE)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_DeviceName">device name</A>with char code identifier and insert it to MIDITrack. If char code is MIDIEVENT_NOCHARCODE, no identifier is added but pszText is encoded by sequence's nearest copyright notice event's char code. If copyright notice event's char code identifier is not found in the sequence, pszText is encoded by char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertChannelPrefix"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertChannelPrefix <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lNum : Channel number (0〜15)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new<A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A> event and insert it to MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertPortPrefix"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertPortPrefix <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lNum : Port number (0〜255)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_PortPrefix">port prefix</A> event and insert it to MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertEndofTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertEndofTrack <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_EndofTrack">end of track</A> event and insert it to MIDITrack. <SPAN CLASS="RED">If lTime is before of the last event, lTime is automatically modified.</SPAN><SPAN CLASS="RED">If MIDITrack already has end of track event, nothing happens and returns 0.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertTempo"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertTempo <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lTempo);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lTempo : Tempo [microsec / quarter note]</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_Tempo">tempo</A> event and insert it to MIDITrack. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, pMIDITrack must be the first track.</SPAN> <SPAN CLASS="RED">lTempo's unit is microsec per quarter note.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertSMPTEOffset"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertSMPTEOffset <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lMode, <SPAN CLASS="KEYWORD">long</SPAN> lHour, <SPAN CLASS="KEYWORD">long</SPAN> lMin, <SPAN CLASS="KEYWORD">long</SPAN> lSec, <SPAN CLASS="KEYWORD">long</SPAN> lFrame, <SPAN CLASS="KEYWORD">long</SPAN> lSubFrame);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lMode: Mode (0〜3)<BR>lHour : Hour (0〜23)<BR>lMin : Minute (0〜59)<BR>lSec :  Sec (0〜59)<BR>lFrame : Frame (0〜30※)<BR>lSubFrame : Subframe (0〜99)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A> event and insert it to MIDITrack. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, pMIDITrack must be the first track. </SPAN><SPAN CLASS="RED">lTime must be 0.</SPAN> lMode can be MIDIEVENT_SMPTE24(0), MIDIEVENT_SMPTE25(1), MIDIEVENT_SMPTE30D(2), or MIDIEVENT_SMPTE30N(3). <SPAN CLASS="RED">lSubFram's unit is 1/100 frame.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertTimeSignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertTimeSignature <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lnn, <SPAN CLASS="KEYWORD">long</SPAN> ldd, <SPAN CLASS="KEYWORD">long</SPAN> lcc, <SPAN CLASS="KEYWORD">long</SPAN> lbb);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lnn : Numerator<BR>ldd : Denominator's power<BR>lcc : MIDI clocks per quarter note (=24)<BR>lbb : demisemiquarver per quarter note (=8)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_TimeSignature">time signature</A> and insert it to MIDITrack. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, pMIDITrack must be the first track. </SPAN>ldd's value is power of 2.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertKeySignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertKeySignature <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lsf, <SPAN CLASS="KEYWORD">long</SPAN> lmi);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lsf: number of # or ♭ (-7 〜 +7)<BR>lmi : major=0, minor=1</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_KeySignature">key signature</A> event and insert it to MIDITrack. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, pMIDITrack must be the first track. </SPAN>。If lsf is positive, lsf is number of #. If lsf is negative, lsf is number of ♭. If lsf is zero, no # or no ♭。lmi can be MIDIEVENT_KEYMAJOR(=0) or MIDIEVENT_KEYMINOR(=1).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertSequencerSpecific"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertSequencerSpecific <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, char* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pBuf : Pointer to specific data<BR>lLen : length of data [bytes]</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_SequencerSpecific">sequencer specific</A> event and inisert it MIDITrack. The first byte of data must be identifier of manufacture.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertNoteOff"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertNoteOff <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOff">note off</A> event and insert it MIDITrack. If you need to both note on event and note off event, you should use <A HREF="#MIDITrack_InsertNote">MIDITrack_InsertNote</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertNoteOn"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertNoteOn <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh: Channel (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOn">note on</A> event and insert it to MIDITrack. If velocity is zero, it works as note off event. If you need to both note on event and note off event, you should use <A HREF="#MIDITrack_InsertNote">MIDITrack_InsertNote</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertKeyAftertouch"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertKeyAftertouch <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lKey : Key (0〜127)<BR>lVal : Value (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A> event and insert it to MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertControlChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertControlChange <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lNum, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lNum : Control number (0〜127)<BR>lVal : Value (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change</A> event and insert it to MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertProgramChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertProgramChange <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lNum : Program number (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ProgramChange">program change</A> event and insert it to MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertChannelAftertouch"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertChannelAftertouch <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lVal : Value (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A> event and insert it to MIDITrack.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertPitchBend"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertPitchBend <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lVal : Value (0〜16383)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event and isnert it to MIDITrack. Be careful that lVal's middle value is 8192.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertSysExEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertSysExEvent <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">unsigned char</SPAN>* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>pBuf : Pointer to system exclusive data<BR>lLen : Length of data [bytes]</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_SysExEvent">system exclusive event</A> and insert it to MIDITrack. Generally, one system exclusive data begin with 0xF0 and end with 0xF7. But, when dividing a long system exclusive data, not necessary to begin with 0xF0 or end with 0xF7. If begin with 0xF0, <A HREF="#MIDIEvent_SysExTable">system exclusive event's kind</A> becomes normal, otherwise, becomes arbitrary.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertNote"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertNote <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel, <SPAN CLASS="KEYWORD">long</SPAN> lDur);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : lChannel (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity of note on<BR>lDur : Duration (1〜) [ticks] or [subframes]</TD>
  <TD>Successful : 2<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOn">note on event</A> and <A HREF="#MIDIEvent_NoteOff">note off event</A> and insert them to MIDITrack. Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertPatchChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertPatchChange <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lCC0, <SPAN CLASS="KEYWORD">long</SPAN> lCC32, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A><BR>(※Unrecommended)</TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lCC0 : CC#0(Bank Select MSB)'s value (0〜127)<BR>lCC32 : CC#32(Bank Select LSB)'s value (0〜127)<BR>lNum : Program number (0〜127)</TD>
  <TD>Successful : 3 or 4<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change CC#0(Bank Select MSB)</A>, <A HREF="#MIDIEvent_ControlChange">control change CC#32(Bank Select LSB)</A>, and <A HREF="#MIDIEvent_ProgramChange">program change</A> event, and insert them to MIDITrack. Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertRPNChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertRPNChange <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lCC101, <SPAN CLASS="KEYWORD">long</SPAN> lCC100, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A><BR>(※Unrecommended)</TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lCC101 : CC#101(RPN MSB)'s value (0〜127)<BR>lCC100 : CC#100(RPN LSB)'s value (0〜127)<BR>lVal : CC#6(Data Entry MSB)'s value (0〜127)</TD>
  <TD>Successful : 3 or 4<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change CC#101(RPN MSB)</A>, <A HREF="#MIDIEvent_ControlChange">control cahnge CC#100(RPN LSB)</A>, and <A HREF="#MIDIEvent_ControlChange">control change CC#6(Data Entry MSB)</A> event, and insert them to MIDITrack. Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_InsertNRPNChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_InsertNRPNChange <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lCC99, <SPAN CLASS="KEYWORD">long</SPAN> lCC98, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A><BR>(※Unrecommended)</TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lCC99 : CC#99(NRPN MSB)'s value (0〜127)<BR>lCC98 : CC#98(NRPN LSB)'s value (0〜127)<BR>lVal : CC#6(Data Entry MSB)'s value (0〜127)</TD>
  <TD>Successful : 3 or 4<BR>Failed : 0</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change CC#99(NRPN MSB)</A>, <A HREF="#MIDIEvent_ControlChange">control change CC#98(NRPN LSB)</A>, <A HREF="#MIDIEvent_ControlChange">control change CC#6(Data Entry MSB)</A> event, and insert them to MIDITrack. Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDITrack_RemoveEventFunction">3-6. Remove MIDIEvent from MIDITrack</A></H3>

<P> You can remove MIDIEvent from MIDITrack by using MIDITrack_Remove functions. These functios remove MIDIEvent from MIDITrack, but does not delete MIDIEvent on the memeory. To delete MIDIEvent, please use <A HREF="#MIDIEvent_DeleteFunction">MIDIEvent_Delete</A> functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDIData_RemoveTrackFunctionList">▼List3-6. How to use MIDITrack_RemoveEvent functions</A></DIV>
<PRE>
	<SPAN CLASS="COMMENT">/* Remove the first event in the Track */</SPAN>
	MIDITrack_RemoveEvent (pMIDIData, pMIDITrack-&gt;m_pFirstEvent);
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_RemoveFunctionTable">▼Table3-6. Table of MIDITrack_RemoveEvent functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_RemoveEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_RemoveEvent <BR>(MIDITrack* pMIDITrack, MIDIEvent* pMIDIEvent);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Successful : Number of removed event<BR>Failed : 0</TD>
  <TD>Remove specified MIDIEvent from MIDITrack. <SPAN CLASS="RED">If pMIDIEvent is combined such as note on and note off, all combined event are removed.</SPAN> List pointer is automatically updated. This function does NOT delete MIDIEvent on the memory.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_RemoveSingleEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_RemoveSingleEvent <BR>(MIDITrack* pMIDITrack, MIDIEvent* pMIDIEvent);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Remove specified MIDIEvent from MIDITrack. <SPAN CLASS="RED">If pMIDIEvent is combined such as note on and note off, each event is automatically chopped and remove only one event.</SPAN> List pointer is automatically updated. This function does NOT delete MIDIEvent on the memory.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDITrack_IsFunction">3-7. Test MIDITrack's status</A></H3>

<P> You can test MIDITrack's status by using MIDITrack_Is functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_IsFunctionTable">▼Table3-7. Table of MIDITrack_Is functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR CLASS="TITLE">
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_IsFloating"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_IsFloating <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether MIDITrack is <A HREF="#MIDITrack_FloatTrack">floating</A></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_CheckSetupTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_CheckSetupTrack <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Valid : 1<BR>Error : 0</TD>
  <TD>Test whether MIDITrack is valid <A HREF="#MIDITrack_SetupTrack">conductor track</A>. Conductor track must not contain <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> (event's kind = 0x80〜0xEF). If <A HREF="#MIDIData_Format1">format1</A>, the first track must be conductor track.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_CheckNonSetupTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_CheckNonSetupTrack <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Valid : 1<BR>Error : 0</TD>
  <TD>Test whether MIDITrack is valid <A HREF="#MIDITrack_NonSetupTrack">non conductor track</A>. Non conductor track must not contain (<A HREF="#MIDIEvent_Tempo">tempo</A>, <A HREF="#MIDIEvent_SMPTEOffset">SMPTEoffset</A>, <A HREF="#MIDIEvent_TimeSignature">time signature</A>, and <A HREF="#MIDIEvent_KeySignature">key signature</A> event. If <A HREF="#MIDIData_Format1">format1</A>, the second or followinig track must be non conductor track.</TD>
 </TR>
</TABLE>


<H3><A NAME="MIDITrack_GetFunction">3-8. Get MIDITrack's property</A></H3>

<P> You can get MIDITrack's property by using MIDITrack_Get functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_GetFunctionTable">▼Table3-8. Table of MIDITrack_Get functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetFirstEvent">MIDIEvent* MIDITrack_GetFirstEvent <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Pointer to the first MIDIEvent</TD>
  <TD>Get pointer to the first event in the MIDITrack. If MIDITrack has no event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetLastEvent">MIDIEvent* MIDITrack_GetLastEvent <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Pointer to the last MIDIEvent</TD>
  <TD>Get pointer to the last event in the MIDITrack. If MIDITrack has no event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetFirstKindEvent">MIDIEvent* MIDITrack_GetFirstKindEvent <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lKind);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lKind : Event's kind</TD>
  <TD>Pointer to the first specified kind's MIDIEvent</TD>
  <TD>Get pointer to  the first specified kind's event in the MIDITrack. If MIDITrack has no specified kind's event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetLastKindEvent">MIDIEvent* MIDITrack_GetLastKindEvent <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lKind);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lKind : Event's kind</TD>
  <TD>Pointer to the last specified kind's MIDIEvent</TD>
  <TD>Get pointer to the last specified kind's event in the MIDITrack. If MIDITrack has no specified kind's event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetPrevTrack">MIDITrack* MIDITrack_GetPrevTrack <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Pointer to previous track</TD>
  <TD>Get pointer to previous track. If there is no previous track, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetNextTrack">MIDITrack* MIDITrack_GetNextTrack <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Pointer to the next track.</TD>
  <TD>Get pointer to the next track. If there is no next track, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetParent">MIDIData* MIDITrack_GetParent <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Pointer to parent MIDIData.</TD>
  <TD>Get pointer to parent MIDIData. If floating, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetBeginTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetBeginTime <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Track's begin time</TD>
  <TD>Get the first event's time in the MIDITrack. If MIDITrack has no event, returns 0.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetEndTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetEndTime <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Track's end time</TD>
  <TD>Get the last event's time in the MIDITrack. If MIDITrack has no event, returns 0.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetName">TCHAR* MIDITrack_GetName <BR>(MIDITrack* pMIDITrack, TCHAR* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pBuf : Pointer to buffer for writeing text<BR>lLen : Buffer's size [characters]</TD>
  <TD>Pointer to the track name</TD>
  <TD>Get the first <A HREF="#MIDIEvent_TrackName">track name</A> event's text. If MIDITrack has no track name event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetInputOn"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetInputOn <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Input on/off (0=OFF, 1=ON)</TD>
  <TD>Get m_lInputOn's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetInputPort"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetInputPort <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Input port (0〜255)</TD>
  <TD>Get m_lInputPort's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetInputChannel"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetInputChannel <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Input channel (-1=n/a, 0〜15)</TD>
  <TD>Get m_lInputChannel's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetOutputOn"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetOutputOn <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Output on/off (0=OFF, 1=ON)</TD>
  <TD>Get m_lOutputOn's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetOutputPort"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetOutputPort <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Output port (0〜255)</TD>
  <TD>Get m_lOutputPort's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetOutputChannel"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetOutputChannel <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Output channel (-1=n/a, 0〜15)</TD>
  <TD>Get m_lOutputChannel's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetTimePlus"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetTimePlus <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Time+</TD>
  <TD>Get m_lTimePlus's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetKeyPlus"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetKeyPlus <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Key+</TD>
  <TD>Get m_lKeyPlus's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetVelocityPlus"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetVelocityPlus <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Velocity+</TD>
  <TD>Get m_lVelocityPlus's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetViewMode"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetViewMode <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>View mode (0=normal, 1=drum)</TD>
  <TD>Get m_lViewMode's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetForeColor"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetForeColor <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Foreground color</TD>
  <TD>Get m_lForeColor's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetBackColor"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetBackColor <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Background color</TD>
  <TD>Get m_lBackColor's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_GetXFVersion"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_GetXFVersion <BR>(MIDITrack* pMIDITrack);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack</TD>
  <TD>Version of XF data (YAMAHA's extended format). </TD>
  <TD>If this MIDITrack has XF data's sequencer specific event, get the version of XF data. Return value is caluclated from sequencer specific event {43 7B 00 58 46 Mj Mn S1 S0}, and return value is (Mj | (Mn &lt;&lt; 8) | (S1 &lt;&lt; 16) | (S0 &lt;&lt; 24)). If not XF data, returns 0.</TD> </TR>
</TABLE>

<H3><A NAME="MIDITrack_SetFunction">3-9. Set MIDITrack's property</A></H3>

<P> You can set MIDITrack's property by usinig MIDITrack_Set functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_SetFunctionTable">▼Table3-9. Table of MIDITrack_Set functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR CLASS="TITLE">
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetName"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetName <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>pszText : Pointer to null terminated string</TD>
  <TD>Undefined</TD>
  <TD>Set the first <A HREF="#MIDIEvent_TrackName">track name</A> event's text in the MIDITrack. If the MIDITrack has no track name event, a track name event is automatically added at the time 0.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetInputOn"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetInputOn <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lInputOn);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lInputOn : Input on/off (0=OFF, 1=ON)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lInputOn's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetInputPort"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetInputPort <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lInputPort);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lInputPort : Input port (0〜255)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lInputPort's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetInputChannel"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetInputChannel <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lInputChannel);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lInputChannel: Input channel (-1=n/a, 0〜15)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lInputChannel's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetOutputOn"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetOutputOn <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lOutputOn);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lOutputOn : Output on/off (0=OFF, 1=ON)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lOutputOn's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetOutputPort"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetOutputPort <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lOutputPort);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lOutputPort:出力ポート(0〜255)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lInputPort's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetOutputChannel"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetOutputChannel <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lOutputChannel);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lOutputChannel : Output channel (-1=n/a, 0〜15)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lOutputChannel's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetTimePlus"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetTimePlus <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTimePlus);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTimePlus : Time+</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lTimePlus's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetKeyPlus"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetKeyPlus <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lKeyPlus);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lKeyPlus : Key+</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lKeyPlus's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetVelocityPlus"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetVelocityPlus <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lVelocityPlus);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lVelocityPlus : Velocity+</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lVelocityPlus's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetViewMode"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetViewMode <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lViewMode);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lViewMode : View mode (0=normal, 1=drum)</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lViewMode's value</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetForeColor"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetForeColor <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lForeColor);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lForeColor : Foreground color</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lForeColor's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_SetBackColor"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_SetBackColor <BR>(MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lBackColor);</A> </TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lBackColor : Background color</TD>
  <TD>Successful : 1, Failed : 0</TD>
  <TD>Set m_lBackColor's value.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDITrack_OtherFunction">3-10. Other MIDITrack functions</A></H3>

<DIV CLASS="TITLE"><A NAME="MIDITrack_OtherFunctionTable">▼Table3-10. Table of MIDITrack_Other functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR CLASS="TITLE">
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_CountEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_CountEvent (MIDITrack* pMIDITrack);</A></TD>
  <TD>pMIDIData : Pointer to MIDITrack</TD>
  <TD>Number of MIDIEvents</TD>
  <TD>Count number of MIDIEvents in the MIDITrack and update <A HREF="#MIDITrack_FieldTable">m_lNumEvent</A>'s value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_TimeToMillisec"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_TimeToMillisec (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time [ticks] or [subframes]</TD>
  <TD>Millisec</TD>
  <TD>Convert absolute time [ticks] or [subframes] to [millisec]. This function calculate by using only specified track's <A HREF="#MIDIEvent_Tempo">tempo</A> events. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this function should be used only for the first track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_MillisecToTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_MillisecToTime (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lMillisec);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lMillisec : [millisec]</TD>
  <TD>Absolute time [ticks] or [subframes]</TD>
  <TD>Convert [millisec] to absolute time [ticks] or [subframes]. This function calculate by using only specified track's <A HREF="#MIDIEvent_Tempo">tempo</A> event. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this function should be used only for the first track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_MakeTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_MakeTime (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lMeasure, <SPAN CLASS="KEYWORD">long</SPAN> lBeat, <SPAN CLASS="KEYWORD">long</SPAN> lTick, <SPAN CLASS="KEYWORD">long</SPAN>* pTime);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lMeasure : Measure number (0〜)<BR>lBeat : Beat number (0〜)<BR>lTick : Tick number (0〜)<BR>pTime : Pointer to buffer for write absolute time [ticks]</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>If TPQN base, convert [measure : beat : tick] to absolute time [ticks]. This function calculate by using only specified track's <A HREF="#MIDIEvent_TimeSignature">time signature</A> events. If SMPTE base, convert [frame : subframe] to absolute time [subframes]. In this case, specify frame in lMeasure, subframe in lTick. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this function should be used only for the first track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_MakeTimeEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_MakeTimeEx (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lMeasure, <SPAN CLASS="KEYWORD">long</SPAN> lBeat, <SPAN CLASS="KEYWORD">long</SPAN> lTick, <SPAN CLASS="KEYWORD">long</SPAN>* pTime, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lMeasure : Measure number (0〜)<BR>lBeat : Beat number (0〜)<BR>lTick : Tick number (0〜)<BR>pTime : Pointer to buffer for write absolute time<BR>pnn：Pointer to buffer for write numerator<BR>pdd : Pointer to buffer for write denominator's power<BR>pcc : Pointer to buffer for write clocks per quarter note<BR>pbb : Pointer to buffer for write demisemiquarver per quarter note</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>This function is same as <A HREF="#MIDITrack_MakeTime">MIDITrack_MakeTime</A>, but additionally get nearest <A HREF="#MIDIEvent_TimeSignature">time signature</A> event's property. But if SMPTE base, you may not get time signature's property.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_BreakTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_BreakTime (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pMeasure, <SPAN CLASS="KEYWORD">long</SPAN>* pBeat, <SPAN CLASS="KEYWORD">long</SPAN>* pTick);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute Time [ticks]<BR>pMeasure : Pointer to buffer for write measure number (0〜)<BR>pBeat : Pointer to buffer for write beat number (0〜)<BR>pTick : Pointer to buffer to write tick number (0〜)</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>If TPQN base, convert absolute time [ticks] to [measure : beat : tick]. This function calculate by using only specified track's <A HREF="#MIDIEvent_TimeSignature">time signature</A> events. If SMPTE base, convert absolute time [subframes] to [frame : subframe]. In this case, frame is written in pMeasure, and subframe is written in pTick. If <SPAN CLASS="RED"> <A HREF="#MIDIData_Format1">format1</A>, this function should be used for only the first track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_BreakTimeEx"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_BreakTimeEx (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pMeasure, <SPAN CLASS="KEYWORD">long</SPAN>* pBeat, <SPAN CLASS="KEYWORD">long</SPAN>* pTick, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute Time [ticks]<BR>pMeasure : Pointer to buffer for write measure number (0〜)<BR>pBeat : Pointer to buffer for write beat number (0〜)<BR>pTick : Pointer to buffer to write tick number (0〜)<BR>pnn：Pointer to buffer for write  numerator<BR>pdd : Pointer to buffer for write denominator's power<BR>pcc : Pointer to buffer for write clocks per quarter note<BR>pbb : Pointer to buffer for write demisemiquarver per quarter note</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>This function is same as <A HREF="#MIDITrack_BreakTime">MIDITrack_BreakTime</A>, but additionally get nearest <A HREF="#MIDIEvent_TimeSignature">time signature</A> event's property. But if SMPTE base, you may not get time signature event's property.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_FindTempo"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_FindTempo (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pTempo);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time [ticks]<BR>pTempo : Pointer to Buffer for write tempo.</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Get nearest tempo event's tempo at lTime. This function search only specified track's <A HREF="#MIDIEvent_Tempo">tempo</A> events. <SPAN CLASS="RED">Be careful that tempo's unit is [microsec / quarter note]. If tempo event is not found, returns 500000 [microsec / quarter note] as default tempo.</SPAN> <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this function should be used for only the first track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_FindTimeSignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_FindTimeSignature (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>Absolute time [ticks]<BR>pnn : Pointer to buffer for write numerator<BR>pdd : Pointer to buffer for write denominator's power<BR>pcc : Pointer to buffer for write clocks per quarter note<BR>pbb : Pointer to buffer for write demisemiquarver per quarter note.</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Get Nearest time signature event's property at lTime. This function searches only specified track's <A HREF="#MIDIEvent_TimeSignature">time signature</A> event. If time signature event is not found, returns 4/4, 24[clocks / quarter note], 8[demisemiquarver / quarter note] as default. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this function should be used for only the first track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDITrack_FindKeySignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDITrack_FindKeySignature (MIDITrack* pMIDITrack, <SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN>* psf, <SPAN CLASS="KEYWORD">long</SPAN>* pmi);</A></TD>
  <TD>pMIDITrack : Pointer to MIDITrack<BR>lTime : Absolute time [ticks]<BR>psf : Pointer to buffer for write number of # or ♭.<BR>pmi : Pointer to buffer to write major or minor</TD>
  <TD>Successful ： non 0<BR>Failed ： 0</TD>
  <TD>Get nearest key signature event's property at lTime. This function searches only the first track's <A HREF="#MIDIEvent_KeySignature">key signature</A> event. If psf is positive, it means number of #, if psf is negative, it means number of ♭, and if psf is 0, it means non # or ♭. If pmi MIDIEVENT_KEYMAJOR(0), it means major, and if pmi is MIDIEVENT_KEYMINOR(1), it means minor. <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this function should be used for only the first track.</SPAN></TD>
 </TR>
</TABLE>


<H3><A NAME="MIDITrack_forEachEvent">3-11. forEachEvent</A></H3>

<P> In order to access each event in the MIDITrack, you can use forEachEvent or forEachEventInverse macro.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_forEachEventList1">▼List3-11-1. How to use forEachEvent macro</A></DIV>
<PRE>
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDITrack* pMIDITrack;
	MIDIEvent* pMIDIEvent;
	...
	<SPAN CLASS="COMMENT">/* Print each event's property in the MIDITrack */</SPAN>
	forEachEvent (pMIDITrack, pMIDIEvent) {
		printf (<SPAN CLASS="STRING">"%s\n"</SPAN>, MIDIEvent_ToString (pMIDIEvent, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
	}
</PRE>

<P> Following program is just same as above program.</P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_forEachEventList2">▼List3-11-2. Just same as above program</A></DIV>
<PRE>
	<SPAN CLASS="KEYWORD">char</SPAN> szBuf[1024];
	MIDITrack* pMIDITrack;
	MIDIEvent* pMIDIEvent;
	...
	<SPAN CLASS="COMMENT">/* Print each event's property in the MIDITrack */</SPAN>
	pMIDIEvent = pMIDITrack-&gt;m_pFirstEvent;
	<SPAN CLASS="KEYWORD">while</SPAN> (pMIDIEvent) {
		printf (<SPAN CLASS="STRING">"%s\n"</SPAN>, MIDIEvent_ToString (pMIDIEvent, szBuf, <SPAN CLASS="KEYWORD">sizeof</SPAN>(szBuf)));
		pMIDIEvent = pMIDIEvent-&gt;m_pNextEvent;
	}
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_forEachEventTable">▼Table3-11. Table of forEachEvent macros</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="40%">Syntax</TH>
  <TH WIDTH="60%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="forEachEvent"></A>forEachEvent (pMIDITrack, pMIDIEvent) {<BR> ...<BR>}</TD>
  <TD>Evaluate each MIDIEvent in the MIDITrack from ahead to tail.</TD>
 </TR>
 <TR>
  <TD><A NAME="forEachEventInverse"></A>forEachEventInverse (pMIDITrack, pMIDIEvent) {<BR> ...<BR>}</TD>
  <TD>Evaluate each MIDIEvent in the MIDITrack from tail to ahead.</TD>
 </TR>
</TABLE>

<P> <SPAN CLASS="RED">Be careful not to insert or add MIDIEvent in the forEachEvent scope. It may cause making infinite loop. If need, you should copy each MIDIEvent's pointer to your local array at first, and then insert or add MIDIEvents by using copied pointer.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_forEachEventList3">▼List3-11-3. Bad program</A></DIV>
<PRE>
	...
	forEachEvent (pMIDIData, pMIDITrack) {
		MIDIEvent* pNewEvent = MIDIEvent_Create (pMIDIData-&gt;m_lTime, MIDIEVENT_TEXTEVENT, "a", 1);
		MIDITrack_InsertEvent (pMIDITrack, pNewEvent);
	}
</PRE>

<P> <SPAN CLASS="RED">Be careful not to remove or delete MIDIEvent in the forEachEvent scope. It may cause null pointer error. If need, you should copy each MIDIEvent's pointer to your local array at first, and then remove or delete MIDIEvent by using copied pointer.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDITrack_forEachEventList6">▼List3-11-6. Bad program</A></DIV>
<PRE>
	...
	forEachEvent (pMIDITrack, pMIDIEvent) {
		MIDIEvent_DeleteSingle (pMIDIEvent);
	}
</PRE>

<P></P>

<P> <SPAN CLASS="RED">Be careful that <A HREF="#MIDIEvent_Delete">MIDIEvent_Delete</A> may delete two or three events. To avoid this, please use <A HREF="#MIDIEvent_DeleteSingle">MIDIEvent_DeleteSingle</A>.</SPAN></P>

<P> <SPAN CLASS="RED">Be careful not to modify event's order by using <A HREF="#MIDIEvent_SetTime">MIDIEvent_SetTime</A> or <A HREF="#MIDIEvent_SetTimeSingle">MIDIEvent_SetTimeSingle</A> function in the forEachEvent scope. If need, you should copy each event's pointer to your local array at first, and then modify event's time by using copied pointer.</SPAN></P>



<H2><A NAME="MIDIEvent">Chapter4 : MIDIEvent</A></H2>

<H3><A NAME="MIDIEvent_Struct">4-1. Structure of MIDIEvent</A></H3>

<P> MIDIEvent has property of time, event's kind, and event's data. MIDIEvent is element of link list, so it has pointer to the previous event and next event. MIDIEvent belongs to one MIDITrack, so it has pointer to parent MIDITrack.</P>

<P> Following are table of MIDIEvent's field. You can get these fields by using <A HREF="#MIDIEvent_GetFunction">MIDIEvent_Get</A> functions and set these fields by using <A HREF="#MIDIEvent_SetFunction">MIDIEvent_Set</A> functions. Part of these field is sequencer specific field, so not saved in standard MIDI file(*.mid)</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_FieldTable">▼Table4-1. Table of MIDIEvent structure</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Fields</TH>
  <TH WIDTH="75%">Remarks</TH>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lTime</TD>
  <TD>MIDIEvent's absolute time. If TPQN base, the unit is [tick]. If SMPTE base, the unit is [subframes]. Be careful that in standard MIDI file(*.mid), time is saved as relative time from previous event.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lKind</TD>
  <TD><A HREF="#MIDIEvent_Kind">MIDIEvent's kind</A>, between <A HREF="#MIDIEvent_SequenceNumber">MIDIEVENT_SEQUENCENUMBER</A>(0x00) and <A HREF="#MIDIEvent_SysExStart">MIDIEVENT_SYSEXCONTINUE</A>(0xF7).。</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lLen</TD>
  <TD>MIDIEvent's data's size [bytes].</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">unsigned char</SPAN>* m_pData</TD>
  <TD>Pointer to MIDIEvent's data buffer. If <A HREF="#MIDIEvent_MetaEvent">meta event</A> or <A HREF="#MIDIEvent_SysExEvent">system exclusive event</A>, the data may be longer than 4 bytes, so this pointer keeps external allocated buffer. If <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A>, the data is shorer than 4 bytes, so this pointer keeps m_lData's address.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">unsigned long</SPAN> m_lData</TD>
  <TD>MIDIEvent's data (4bytes)。This buf is used for only <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI Channel event</A>. Other kind of event does not use this field, but use external allocated buffer.</TD>
 </TR>
 <TR>
  <TD>MIDIEvent* m_pNextEvent</TD>
  <TD>Pointer to next MIDIEvent. If there is no next MIDIEvent, NULL.</TD>
 </TR>
 <TR>
  <TD>MIDIEvent* m_pPrevEvent</TD>
  <TD>Pointer to previous MIDIEvent. If there is no previous MIDIEvent, NULL.</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">void</SPAN>* m_pParent</TD>
  <TD>Pointer to parent MIDITrack. If there is no parent MIDITrack, NULL.</TD>
 </TR>
 <TR>
  <TD>MIDIEvent* m_pNextSameKindEvent</TD>
  <TD>Pointer to next same kind's MIDIEvent. If there is no next same kind's MIDIEvent, NULL.</TD>
 </TR>
 <TR>
  <TD>MIDIEvent* m_pPrevSameKindEvent</TD>
  <TD>Pointer to previous same kind's MIDIEvent. If there is no previous same kind's MIDIEvent, NULL.</TD>
 </TR>


 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser1</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser2</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUser3</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
 <TR>
  <TD><SPAN CLASS="KEYWORD">long</SPAN> m_lUserFlag</TD>
  <TD>32bit user area. This is a sequencer specific field, so not saved to standard MIDI file(*.mid).</TD>
 </TR>
</TABLE>  

<H3><A NAME="MIDIEvent_Kind">4-2. MIDIEvent's kind</A></H3>

<P> There are 3 types of MIDIEvent, which is, <A HREF="#MIDIEvent_MetaEvent">meta event</A>、<A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A>、<A HREF="#MIDIEvent_SysExEvent">system exclusive event</A>.</P>

<H4><A NAME="MIDIEvent_MetaEvent">Meta event</A></H4>
<P> Meta event contains track name, text, copyright notice, time signature, key signature and so on. Meta event is NOT MIDI message, so you can't send or receive meta event. Meta event is complementary event, so even if you ignore all meta event (except <A HREF="#MIDIEvent_Tempo">tempo</A> event), you can play MIDI data exactly.</P>

<P> You can test whether MIDIEvent is meta event or not by using <A HREF="#MIDIEvent_IsMetaEvent">MIDIEvent_IsMetaEvent</A> function.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_MetaTable">▼Table4-2-1. Table of meta event</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="20%">ID</TH>
  <TH WIDTH="10%">Name</TH>
  <TH WIDTH="5%">Data Length</TH>
  <TH WIDTH="5%">Data</TH>
  <TH WIDTH="50%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SequenceNumber">MIDIEVENT_SEQUENCENUMBER</A><BR>(0x00)</TD>
  <TD>Sequence number</TD>
  <TD>2bytes</TD>
  <TD>MSB, LSB</TD>
  <TD>Sequence number contains ID between 0 and 65535. This event can be put in the sequence to selecti position or track by external devices. This event is seldom used.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_TextEvent">MIDIEVENT_TEXTEVENT</A><BR>(0x01)</TD>
  <TD>Text event</TD>
  <TD>Any</TD>
  <TD>String</TD>
  <TD>Text event can contains any strings such as comment. Length does NOT contain last null character. Recommended length is shorter than 128 bytes. If strings begin with "{@LATIN}", string's char code is Latin (CP1252). If strings begin with "{@JP}", string's char code is Shift-JIS (CP932). If strings begin with {0xFF, 0xFE}, string's char code is UTF-16LE. If strings begin with {0xFE, 0xFF}, string's char code is UTF-16BE. Once appear these identifier in the track, following same kind's event's char code is constant until new identifier appears. If no identifier is not found, char code is not defined.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CopyrightNotice">MIDIEVENT_COPYRIGHTNOTICE</A><BR>(0x02)</TD>
  <TD>Copyright notice</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>Describe copyright notice. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_TrackName">MIDIEVENT_TRACKNAME</A><BR>(0x03)</TD>
  <TD>Sequence name / Track name</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>If format0 or format1's the first track, describe sequence name. Else, describe track name. This event should be put each track's at time 0. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_InstrumentName">MIDIEVENT_INSTRUMENTNAME</A><BR>(0x04)</TD>
  <TD>Instrument name</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>Describe instrument's name such as "Poland SC-88Ero" or "YANAHA MV-1000". The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_Lyric">MIDIEVENT_LYRIC</A><BR>(0x05)</TD>
  <TD>Lyric</TD>
  <TD>Any</TD>
  <TD>String</TD>
  <TD>Describe lyric. This event should be put with each note on event. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_Marker">MIDIEVENT_MARKER</A><BR>(0x06)</TD>
  <TD>Marker</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>Describe positional marker such as "[A]", "[B]". If <A HREF="#MIDIData_Format1">fomrat1</A>, This event should be put in the first track. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CuePoint">MIDIEVENT_CUEPOINT</A><BR>(0x07)</TD>
  <TD>Cue point</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>Describe positional cue point.  If <A HREF="#MIDIData_Format1">fomrat1</A>, This event should be put in the first track. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_ProgramName">MIDIEVENT_PROGRAMNAME</A><BR>(0x08)</TD>
  <TD>Program name</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>Describe program name such as "Ground Piano1", "Strings1". This is only only for view, so to select program, use <A HREF="#MIDIEvent_ProgramChange">program change</A> event. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_DeviceName">MIDIEVENT_DEVICENAME</A><BR>(0x09)</TD>
  <TD>Device name</TD>
  <TD>Any</TD>
  <TD>Variable-length string</TD>
  <TD>Describe port's name such as "ADSP24 MPU401 Port1 (1)", "Out-A USB MidiSport 8x8". This is only for view, so to select port, use <A HREF="#MIDIEvent_PortPrefix">port prefix</A> event. The specification is same as text event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_ChannelPrefix">MIDIEVENT_CHANNELPREFIX</A><BR>(0x20)</TD>
  <TD>Channel prefix</TD>
  <TD>1byte</TD>
  <TD>Channel number (0〜15)</TD>
  <TD>This is used to select output channel. But each MIDI channel event has channel information, so you don't need to use this event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_PortPrefix">MIDIEVENT_PORTPREFIX</A><BR>(0x21)</TD>
  <TD>Port prefix</TD>
  <TD>1byte</TD>
  <TD>Port number (0〜255)</TD>
  <TD>This is used to select output port when use multiple sound module or synthesizer. But this is unofficial in MIDI1.0.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_EndofTrack">MIDIEVENT_ENDOFTRACK</A><BR>(0x2F)</TD>
  <TD>End of track</TD>
  <TD>0byte</TD>
  <TD>None</TD>
  <TD>This event MUST be put at the end of each track. <SPAN CLASS="RED">In standard MIDI file(*.mid), omitting this event is prohibitted.</SPAN> MIDIDataLibrary does not add this event automatically, so programmers should add this event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_Tempo">MIDIEVENT_TEMPO</A><BR>(0x51)</TD>
  <TD>Set tempo</TD>
  <TD>3bytes</TD>
  <TD>tt tt tt</TD>
  <TD>This event is used to set tempo. Tempo's value is 24bit integer, and <SPAN CLASS="RED">the unit is microsec per quarter note</SPAN>. Tempo's value can be caluclated from (Tempo = 60000000 / BPM). <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this event MUST be put in the first track, and must NOT put in the second or following track.</SPAN> If this event is omitted, the default tempo is 500000[microsec / quarter note](120[beat / minute]).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SMPTEOffset">MIDIEVENT_SMPTEOFFSET</A><BR>(0x54)</TD>
  <TD>SMPTE offset</TD>
  <TD>5bytes</TD>
  <TD>hr mn se fr ff</TD>
  <TD>This event is used to define SMPTE offset. If need, this event must be put at time 0. hr's highest 1bit is always 0, and the next 2bit is frame rate, and the rest 5bit is hour(0〜23). mn is minute(0〜59). se is second(0〜59). fr is frame(0〜23, 24, 29). ff is subframe(0〜99) and subframe's unit 1/100 frame. hr's frame rate can be MIDIEVENT_SMPTE24(0), MIDIEVENT_SMPTE25(1), MIDIEVENT_SMPTE30D(2), or MIDIEVENT_SMPTE30N(3). <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this event MUST be put in the first track, and must NOT put in the second or following track.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_TimeSignature">MIDIEVENT_TIMESIGNATURE</A><BR>(0x58)</TD>
  <TD>Time signature</TD>
  <TD>4bytes</TD>
  <TD>nn bb cc dd</TD>
  <TD>This event is used to set time signature such as 4/4. This event is only for view, so does not affect to playing. nn is numerator. dd is denominator's 2's power. If denominator is 8, dd is 3. cc is number of MIDI clocks per quarter note (=24). bb is number of demisemiquarver per quarter note (=8). <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this event MUST be put in the first track and must NOT put in the second or following track.</SPAN>If omitted, the default time signature is 4/4, 24[clocks / quarter note], 8[demisemiquarver / quarter note], which is, {0x04, 0x02, 0x18, 0x08}.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_KeySignature">MIDIEVENT_KEYSIGNATURE</A><BR>(0x59)</TD>
  <TD>Key signature</TD>
  <TD>2bytes</TD>
  <TD>sf mi</TD>
  <TD>This event is used to set key signature. This is only for view, so this event does not affect to playing. If lsf is positive, lsf is number of #. If lsf is negative, lsf is number of ♭. If lsf is zero, no # or no ♭。lmi can be MIDIEVENT_KEYMAJOR(=0) or MIDIEVENT_KEYMINOR(=1).<SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, this event MUST be put in the first track and must NOT put in the second or following track.</SPAN> If omitted, the default key signature is 0#-major, which is {0x00, 0x00}.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SequencerSpecific">MIDIEVENT_SEQUENCERSPECIFIC</A><BR>(0x7F)</TD>
  <TD>Sequencer sepecific</TD>
  <TD>Any</TD>
  <TD>Variable-length byte array</TD>
  <TD>This event is used to write sequencer specific event. The first byte of data must be manufacture ID. Sequencer should ignore unknown manufacture's sequencer specific event.</TD>
 </TR>
</TABLE>

<H4><A NAME="MIDIEvent_MIDIChannelEvent">MIDI Channel Event</A></H4>

<P> MIDI channel event contains MIDI message to send or receive, such as note on, note off, control change, program change. </P>

<P> In standard MIDI file(*.mid), the first byte of each message called status byte may be omitted if it is same as the previous event in the track. But in MIDIDataLibrary, for keeping each event's independence, The first byte of each message can't be omitted. When loading from standard MIDI file, the status byte is automatically added, and when saving to standard MIDI file, the status byte is automatically removed.</P>

<P> <SPAN CLASS="RED">If <A HREF="#MIDIData_Format1">format1</A>, MIDI channel event must NOT be put in the first track.</SPAN></P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_MIDIChannelEventTable">▼Table4-2-2. Table of MIDI channel event</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="20%">ID</TH>
  <TH WIDTH="10%">Name</TH>
  <TH WIDTH="5%">Data length</TH>
  <TH WIDTH="5%">Data</TH>
  <TH WIDTH="50%">Remarks</TH>
 </TR>

 <TR>
  <TD><A NAME="MIDIEvent_NoteOff">MIDIEVENT_NOTEOFF</A><BR>(0x8n)</TD>
  <TD>Note off</TD>
  <TD>3bytes</TD>
  <TD>0x8n<BR> key<BR> vel</TD>
  <TD>Release key. n is channel number(0〜15). key is key number(0〜127). vel is release velocity(0〜127). This event must be pair with note on event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_NoteOn">MIDIEVENT_NOTEON</A><BR>(0x9n)</TD>
  <TD>Note on</TD>
  <TD>3bytes</TD>
  <TD>0x9n<BR> key<BR> vel</TD>
  <TD>Push key. n is channel number(0〜15). key is key number(0〜127). vel is push velocity(1〜127). <SPAN CLASS="RED">If velocity is 0, it means note off event.</SPAN> This event must be pair with note off event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_KeyAftertouch">MIDIEVENT_KEYAFTERTOUCH</A><BR>(0xAn)</TD>
  <TD>Key aftertouch</TD>
  <TD>3bytes</TD>
  <TD>0xAn<BR> Key<BR> Val</TD>
  <TD>Change pressure after pushing key. n is channel number(0〜15). key is key number(0〜127). val is pressure(0〜127).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_ControlChange">MIDIEVENT_CONTROLCHANGE</A><BR>(0xBn)</TD>
  <TD>Control change</TD>
  <TD>3bytes</TD>
  <TD>0xBn<BR> Num<BR> Val</TD>
  <TD>Change channel's parameters such as moduration(CC#1), volume(CC#7), pan(CC#10), expression(CC#11), hold pedal(CC#64), reverb(CC#91), chorus(CC#93), delay(CC#94) and so on. n is channel number(0〜15). Num is control number(0〜127), Val is set value(0〜127). You can change RPN by using CC#101(RPN MSB) and CC#100(RPN LSB) and CC#6(Data Entry). Also you can change NRPN by using CC#99(NRPN MSB) and CC#98(NRPN LSB) and CC#6(Data Entry).<BR></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_ProgramChange">MIDIEVENT_PROGRAMCHANGE</A><BR>(0xCn)</TD>
  <TD>Program change</TD>
  <TD>2bytes</TD>
  <TD>0xCn<BR> Num</TD>
  <TD>Change channel's tone number such as piano, guitars, strings. n is channel number (0〜15). Num is tone number(0〜127). You can select only 127 tones by using this event, but you can select 2097152 tones by using this event with CC#0(Bank Select MSB) and CC#32(Bank Select LSB).<BR></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_ChannelAftertouch">MIDIEVENT_CHANNELAFTERTOUCH</A><BR>(0xDn)</TD>
  <TD>Channel aftertouch</TD>
  <TD>2bytes</TD>
  <TD>0xDn<BR> Val</TD>
  <TD>Change pressure after key pressed. n is channel number(0〜15). val is pressure(0〜127).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_PitchBend">MIDIEVENT_PITCHBEND</A><BR>(0xEn)</TD>
  <TD>Pitch bend</TD>
  <TD>3bytes</TD>
  <TD>0xEn<BR> LSB<BR> MSB</TD>
  <TD>Change pitch up or down. The value is between 0 and 16384 and the middle value (default) is 8192. The range of changing pitch depends on pitch bend sensitivity. If pitch bend sensitivity is 12, the range is ±1oct. Pitch bend sensitivity can be set by using RPN change (CC#101=0, CC#100=0, CC#6=sensitivity).</TD>
 </TR>
</TABLE>


<H4><A NAME="MIDIEvent_SysExEvent">System exclusive event</A></H4>

<P> System exclusive event contains MIDI message which is particular to individual MIDI device, such as maeter volume, master pan, master effect and so on. For example, GM system on's message is {0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7}. </P>

<P> Generally system exclusive event is longer than <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> and MIDI module requires long time to process, so you should take interval after system exclusive event.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_SysExTable">▼Table4-2-3. System exclusive event</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="20%">ID</TH>
  <TH WIDTH="10%">Name</TH>
  <TH WIDTH="5%">Data length</TH>
  <TH WIDTH="5%">Data</TH>
  <TH WIDTH="50%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SysExStart">MIDIEVENT_SYSEXSTART</A><BR>(0xF0)</TD>
  <TD>System exclusive event (normal)</TD>
  <TD>Any</TD>
  <TD>Variable-length byte array</TD>
  <TD>The data is one system exclusive message or the first part of divided system exclusive message. The data must begin with 0xF0. If the data is one system exclusive message, the data must begin with 0xF0 end end with 0xF7. If length is longer then 128 bytes, you should divide system exclusive event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SysExContinue">MIDIEVENT_SYSEXCONTINUE</A><BR>(0xF7)</TD>
  <TD>System exclusive event (arbitrary)</TD>
  <TD>Any</TD>
  <TD>Variable-length byte array</TD>
  <TD>The data is the following part of divided system exclusive message. The data may not begin with 0xF0. The last part' data must end with 0xF7.</TD>
 </TR>
</TABLE>


<H3><A NAME="MIDIEvent_Status">4-3. Status of MIDIEvent</A></H3>

<H4><A NAME="MIDIEvent_FloatingEvent">Floating</A></H4>
<P> MIDIEvent which does not belongs to any MIDITrack is called floating event. If floating, m_pNextEvent is NULL, m_pPrevEvent is NULL, m_pNextSameKindEvent is NULL, m_pPrevSameKindEvent is NULL, and m_pParent is NULL. Floating event can't be saved to file. You can test whether floating or not by using <A HREF="#MIDIEvent_IsFloating">MIDIEvent_IsFloating</A> function.</P>

<H4><A NAME="MIDIEvent_CombinedEvent">Combined</A></H4>

<P> MIDIEvent which is connected such as note on and note off is called combined event. You can test whether combined or not by using <A HREF="#MIDIEvent_IsCombined">MIDIEvent_IsCombined</A>. You can connect event by using <A HREF="#MIDIEvent_Combine">MIDIEvent_Combine</A> function. Also you can chop event by using <A HREF="#MIDIEvent_Chop">MIDIEvent_Chop</A> function. Be careful MIDIEvent_Delete deletes each combined event at once, and be careful MIDIEvent_SetTime moves each combined event's time at once. In standard MIDI file (*.mid), combined event is saved as chopped event.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_CombineTable">▼Table4-3. Table of combined event</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="20%">Type</TH>
  <TH WIDTH="5%">Number of events</TH>
  <TH WIDTH="25%">Connect pattern</TH>
  <TH WIDTH="50%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_NoteOnNoteOff">Note on + Note off</A></TD>
  <TD>2 events</TD>
  <TD><A HREF="#MIDIEvent_NoteOn">Note on</A> + <A HREF="#MIDIEvent_NoteOff">Note off</A></TD>
  <TD>This is one of typical note event. You can use <A HREF="#MIDIEvent_GetDuration">MIDIEvent_GetDuration</A> and <A HREF="#MIDIEvent_SetDuration">MIDIEvent_SetDuration</A> function.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_NoteOnNoteOn0">Note on + Note on 0</A></TD>
  <TD>2 events</TD>
  <TD><A HREF="#MIDIEvent_NoteOn">Note on</A> + <A HREF="#MIDIEvent_NoteOn">Note on</A> with velocity 0.</TD>
  <TD>This is an another typical note event. Note on event with velocity 0 is used as note off event. You can use <A HREF="#MIDIEvent_GetDuration">MIDIEvent_GetDuration</A> and <A HREF="#MIDIEvent_SetDuration">MIDIEvent_SetDuration</A> function.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_PatchChange">Patch change</A><BR>(※Unrecommended)</TD>
  <TD>3 events</TD>
  <TD><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#0(Bank Select MSB)+<BR><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#32(Bank Select LSB)+<BR><A HREF="#MIDIEvent_ProgramChange">Program change</A><BR>(Order sensitive)</TD>
  <TD>This is a typical patch change event. But this combine is unrecommended. Please use chopped three events.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_RPNChange">RPN change</A><BR>(※Unrecommended)</TD>
  <TD>3 events</TD>
  <TD><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#101(RPN Select MSB)+<BR><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#100(RPN Select LSB)+<BR><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#6(Data Entry MSB)<BR>(Order sensitive)</TD>
  <TD>This is a typical RPN change event. But this combine is unrecommended. Please use chopped three events.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_NRPNChange">NRPN change</A><BR>(※Unrecommended)</TD>
  <TD>3 events</TD>
  <TD><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#99(NRPN Select MSB)+<BR><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#98(NRPN Select LSB)+<BR><A HREF="#MIDIEvent_ControlChange">Control change</A>CC#6(Data Entry MSB)<BR>(Order sensitive)</TD>
  <TD>This is a typical NRPN change event. But this combine is unrecommended\. Please use chopped three events.</TD>
 </TR>
</TABLE>


<H3><A NAME="MIDIEvent_CreateFunction">4-4. Create MIDIEvent</A></H3>

<P> You can create new MIDIEvent on the memory by using MIDIEvent_Create functions. New MIDIEvent is <A HREF="#MIDIEvent_FloatingEvent">floating</A>, so programmers must insert it to MIDITrack.</P>

<P> Following two short example program are creating a new control change CC#11(expression) event at time 480.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_CreateFunctionList">▼List4-3-1. How to use MIDIEvent_Create functions</A></DIV>
<PRE>
	MIDIEvent* pMIDIEvent;
	<SPAN CLASS="KEYWORD">char</SPAN> data[] = {0xB0, 11, 127};
	<SPAN CLASS="COMMENT">/* Create control change event (Time=480, Ch=0, Num=11, Val=127) */</SPAN>
	pMIDIEvent = MIDIEvent_Create (480, MIDIEVENT_CONTROLCHANGE, data, 3);
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDIEvent == NULL) {
		<SPAN CLASS="COMMENT">/* Failed */</SPAN>
		printf (<SPAN CLASS="STRING">"MIDIEvent_Create failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Successful */</SPAN>
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_CreateFunctionList2">▼List4-3-2. How to use MIDIEvent_Create functions</A></DIV>
<PRE>
	MIDIEvent* pMIDIEvent;
	<SPAN CLASS="COMMENT">/* Create control change event (Time=480, Ch=0, Num=11, Val=127) */</SPAN>
	pMIDIEvent = MIDIEvent_CreateControlChange (480, 0, 11, 127);
	<SPAN CLASS="KEYWORD">if</SPAN> (pMIDIEvent == NULL) {
		<SPAN CLASS="COMMENT">/* Failed */</SPAN>
		printf (<SPAN CLASS="STRING">"MIDIEvent_CreateControlChange failed.\n"</SPAN>);
		<SPAN CLASS="KEYWORD">return</SPAN> 0;
	}
	<SPAN CLASS="COMMENT">/* Successful */</SPAN>
	...
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_CreateFunctionTable">▼Table4-4. Table of MIDIEvent_Create functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A Name="MIDIEvent_Create">MIDIEvent* MIDIEvent_Create <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lKind, <SPAN CLASS="KEYWORD">unsigned char</SPAN>* pData, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>lTime : Absolute time<BR>lKind : Event's kind(0x00〜0xFE)<BR>pData : Pointer to data<BR>lLen : Length of data [bytes]</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new arbitrary <A HREF="#MIDIEvent">MIDIEvent</A>. You can specify any event's kind, any data, any length of data. This function does NOT check data. If lKind is MIDI channel event (0x80〜0xEF), you may omit the first byte of the data. In this case, the first byte is automatically added and length is automatically increased 1byte.</TD>
 </TR>
 <TR>
  <TD><A Name="MIDIEvent_CreateClone">MIDIEvent* MIDIEvent_CreateClone <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to souce MIDIEvent</TD>
  <TD>Successful : Pointer to new MIDIEvent<BR>Failed : NULL</TD>
  <TD>Duplicate MIDIEvent. New MIDIEvent is floating. <SPAN CLASS="RED">If pMIDIEvent is combined event, duplicate each combined event.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateSequenceNumber">MIDIEvent* MIDIEvent_CreateSequenceNumber <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>lTime : Absolute time<BR>lNum : Sequence number (0〜65535)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_SequenceNumber">sequence number</A> evebnt. New MIDIEvent is floating.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateTextEvent">MIDIEvent* MIDIEvent_CreateTextEvent <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_TextEvent">text</A> event. This is same as MIDIEvent_CreateTextEventEx (lTime, MIDIEVENT_NOCHARCODE, pszText)</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateTextEventEx">MIDIEvent* MIDIEvent_CreateTextEventEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_TextEvent">text</A> event with char code identifier. If lCharCode is not MIDIEVENT_NOCHARCODE, the pszText is encoded by the lCharCode and an identifier is added to the top of string. If lCharCode is MIDIEVENT_NOCHARCODE but the pszText starts with an identifier such as "{@LATIN}", "{@JP}", "{@UTF-16LE}", "{@UTF-16BE}" or "{@UTF-8}, then the pszText is encoded by the identifier. {@UTF-16LE}, {@UTF-16BE}, {@UTF-8} are converted to {0xFF, 0xFE}, {0xFE, 0xFF}, {0xEF, 0xBB, 0xBF}. If no identifieer is found, no identifier is added and pszText is encoded by the char code specified by MIDIDataLib_SetDefaultCharCode.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateCopyrightNotice">MIDIEvent* MIDIEvent_CreateCopyrightNotice <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event. This is same as MIDIEvent_CreateCopyrightEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateCopyrightNoticeEx">MIDIEvent* MIDIEvent_CreateCopyrightNoticeEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateTrackName">MIDIEvent* MIDIEvent_CreateTrackName <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_TrackName">sequence name / track name</A> event. This is same as MIDIEvent_CreateTrackNameEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateTrackNameEx">MIDIEvent* MIDIEvent_CreateTrackNameEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_TrackName">sequence name / track name</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateInstrumentName">MIDIEvent* MIDIEvent_CreateInstrumentName <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_InstrumentName">instrument name</A> event. This is same as MIDIEvent_CreateInstrumentNameEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateInstrumentNameEx">MIDIEvent* MIDIEvent_CreateInstrumentNameEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_InstrumentName">instrument name</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateLyric">MIDIEvent* MIDIEvent_CreateLyric <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_Lyric">lyric</A> event. This is same as MIDIEvent_CreateLyricEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateLyricEx">MIDIEvent* MIDIEvent_CreateLyricEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_Lyric">lyric</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateMarker">MIDIEvent* MIDIEvent_CreateMarker <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_Marker">marker</A> event. This is same as MIDIEvent_CreateMarkerEx (lTime, MIDIEVENT_NOCHARCODE, pszText)</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateMarkerEx">MIDIEvent* MIDIEvent_CreateMarkerEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_Marker">marker</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateCuePoint">MIDIEvent* MIDIEvent_CreateCuePoint <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_CuePoint">cue point</A> event. This is same as MIDIEvent_CreateCuePointEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateCuePointEx">MIDIEvent* MIDIEvent_CreateCuePointEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_CuePoint">cue point</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateProgramName">MIDIEvent* MIDIEvent_CreateProgramName <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ProgramName">program name</A> event. This is same as MIDIEvent_CreateProgramNameEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateProgramNameEx">MIDIEvent* MIDIEvent_CreateProgramNameEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ProgramName">program name</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateDeviceName">MIDIEvent* MIDIEvent_CreateDeviceName <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>pszText : Poiniter to null terminated strinig</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_DeviceName">device name</A> event. This is same as MIDIEvent_CreateDeviceNameEx (lTime, MIDIEVENT_NOCHARCODE, pszText).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateDeviceNameEx">MIDIEvent* MIDIEvent_CreateDeviceNameEx <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>lTime : Absolute time<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)<BR>pszText : Pointer to null terminated string</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_DeviceName">device name</A> event with char code identifier. The specification is the same as MIDIEvent_CreateTextEventEx.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateChannelPrefix">MIDIEvent* MIDIEvent_CreateChannelPrefix <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>lTime : Absolute time<BR>lNum : Channel number (0〜15)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreatePortPrefix">MIDIEvent* MIDIEvent_CreatePortPrefix <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>lTime : Absolute time<BR>lNum : Port number (0〜255)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_PortPrefix">port prefix</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateEndofTrack">MIDIEvent* MIDIEvent_CreateEndofTrack <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime);</A></TD>
  <TD>lTime : Absolute time</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_EndofTrack">end of track</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateTempo">MIDIEvent* MIDIEvent_CreateTempo <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lTempo);</A></TD>
  <TD>lTime : Absolute time<BR>lTempo : Tempo [microsec / quarter note]</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_Tempo">tempo</A> event. <SPAN CLASS="RED">lTempo's unit is microsec per quarter note.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateSMPTEOffset">MIDIEvent* MIDIEvent_CreateSMPTEOffset <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lMode, <SPAN CLASS="KEYWORD">long</SPAN> lHour, <SPAN CLASS="KEYWORD">long</SPAN> lMin, <SPAN CLASS="KEYWORD">long</SPAN> lSec, <SPAN CLASS="KEYWORD">long</SPAN> lFrame, <SPAN CLASS="KEYWORD">long</SPAN> lSubFrame);</A></TD>
  <TD>lTime : Absolute time<BR>lMode: Mode (0〜3)<BR>lHour : Hour (0〜23)<BR>lMin : Minute (0〜59)<BR>lSec :  Sec (0〜59)<BR>lFrame : Frame (0〜30※)<BR>lSubFrame : Subframe (0〜99)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A> event. lMode can be MIDIEVENT_SMPTE24(0), MIDIEVENT_SMPTE25(1), MIDIEVENT_SMPTE30D(2), or MIDIEVENT_SMPTE30N(3). lFrame must be smaller than frame rate. lSubFrame's unit is 1/100 frame.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateTimeSignature">MIDIEvent* MIDIEvent_CreateTimeSignature <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lnn, <SPAN CLASS="KEYWORD">long</SPAN> ldd, <SPAN CLASS="KEYWORD">long</SPAN> lcc, <SPAN CLASS="KEYWORD">long</SPAN> lbb);</A></TD>
  <TD>lTime : Absolute time<BR>lnn : Numerator<BR>ldd : Denominator's power<BR>lcc : MIDI clocks per quarter note (=24)<BR>lbb : demisemiquarver per quarter note (=8)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_TimeSignature">time signature</A> event. ldd's value is power of 2.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateKeySignature">MIDIEvent* MIDIEvent_CreateKeySignature <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lsf, <SPAN CLASS="KEYWORD">long</SPAN> lmi);</A></TD>
  <TD>lTime : Absolute time<BR>lsf: number of # or ♭ (-7 〜 +7)<BR>lmi : major=0, minor=1</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_KeySignature">key signature</A> event. If lsf is positive, lsf is number of #. If lsf is negative, lsf is number of ♭. If lsf is zero, no # or no ♭。lmi can be MIDIEVENT_KEYMAJOR(=0) or MIDIEVENT_KEYMINOR(=1).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateSequencerSpecific">MIDIEvent* MIDIEvent_CreateSequencerSpecific <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, char* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>lTime : Absolute time<BR>pBuf : Pointer to specific data<BR>lLen : length of data [bytes]</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_SequencerSpecific">sequencer specific</A> event. The first byte of data must be identifier of manufacture.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateNoteOff">MIDIEvent* MIDIEvent_CreateNoteOff <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity (0〜127)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOff">note off</A> event. If you need to create both note on event and note off event, you should use <A HREF="#MIDIEvent_CreateNote">MIDIEvent_CreateNote</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateNoteOn">MIDIEvent* MIDIEvent_CreateNoteOn <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel);</A></TD>
  <TD>lTime : Absolute time<BR>lCh: Channel (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity (0〜127)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOn">note on</A> event. If velocity is zero, it works as note off event. If you need to create both note on event and note on event, you should use <A HREF="#MIDIEvent_CreateNote">MIDIEvent_CreateNote</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateKeyAftertouch">MIDIEvent* MIDIEvent_CreateKeyAftertouch <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lKey : Key (0〜127)<BR>lVal : Value (0〜127)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateControlChange">MIDIEvent* MIDIEvent_CreateControlChange <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lNum, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lNum : Control number (0〜127)<BR>lVal : Value (0〜127)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateProgramChange">MIDIEvent* MIDIEvent_CreateProgramChange <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lNum : Program number (0〜127)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ProgramChange">program change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateChannelAftertouch">MIDIEvent* MIDIEvent_CreateChannelAftertouch <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lVal : Value (0〜127)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreatePitchBend">MIDIEvent* MIDIEvent_CreatePitchBend <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lVal : Value (0〜16383)</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event. Be careful that lVal's middle value is 8192.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateSysExEvent">MIDIEvent* MIDIEvent_CreateSysExEvent <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">unsigned char</SPAN>* pBuf, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>lTime : Absolute time<BR>pBuf : Pointer to system exclusive data<BR>lLen : Length of data [bytes]</TD>
  <TD>Successful : Pointer to MIDIEvent<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_SysExEvent">system exclusive</A> event. Generally, one system exclusive data begin with 0xF0 and end with 0xF7. But, when dividing a long system exclusive data, not necessary to begin with 0xF0 or end with 0xF7. If begin with 0xF0, <A HREF="#MIDIEvent_SysExTable">system exclusive event's kind</A> becomes normal, otherwise, becomes arbitrary.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateNoteOnNoteOff">MIDIEvent* MIDIEvent_CreateNoteOnNoteOff <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel1, <SPAN CLASS="KEYWORD">long</SPAN> lVel2, <SPAN CLASS="KEYWORD">long</SPAN> lDur);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel number (0〜15)<BR>lKey : Key (0〜127)<BR>lVel1 : Velocity of note on (1〜127)<BR>lVel2 : Velocity of note off(0〜127)<BR>lDur : Duration (1〜) [ticks] or [subframes]</TD>
  <TD>Successful : Pointer to note on event<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOn">note on</A> event and new <A HREF="#MIDIEvent_NoteOff">note off</A> event. Each event is <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateNoteOnNoteOn0">MIDIEvent* MIDIEvent_CreateNoteOnNoteOn0 <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel, <SPAN CLASS="KEYWORD">long</SPAN> lDur);</A></TD>
  <TD>lTime : Absolute time<BR>lCh : Channel number (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity of note on (1〜127)<BR>lDur : Duration (1〜) [ticks] or [subframes]</TD>
  <TD>Successful : Pointer to note on event<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_NoteOn">note on</A> event and new <A HREF="#MIDIEvent_NoteOn">note on</A> event with velocity 0 which works as note off event. Each event is <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateNote">MIDIEvent* MIDIEvent_CreateNote <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lKey, <SPAN CLASS="KEYWORD">long</SPAN> lVel, <SPAN CLASS="KEYWORD">long</SPAN> lDur);</A></TD>
  <TD>lTime: Absolute time<BR>lCh : Channel number (0〜15)<BR>lKey : Key (0〜127)<BR>lVel : Velocity of note on (1〜127)<BR>lDur : Duration (1〜) [ticks] or [subframes]</TD>
  <TD>Successful : Pointer to note on event<BR>Failed : NULL</TD>
  <TD>This is same as MIDIEvent_CreateNoteOnNoteOn0.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreatePatchChange">MIDIEvent* MIDIEvent_CreatePatchChange <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lCC0, <SPAN CLASS="KEYWORD">long</SPAN> lCC32, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A><BR>(※Unrecommended)</TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lCC0 : CC#0(Bank Select MSB)'s value (0〜127)<BR>lCC32 : CC#32(Bank Select LSB)'s value (0〜127)<BR>lNum : Program number (0〜127)</TD>
  <TD>Successful : Pointer to CC#0 event<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change CC#0(Bank Select MSB)</A>, <A HREF="#MIDIEvent_ControlChange">control change CC#32(Bank Select LSB)</A>, and <A HREF="#MIDIEvent_ProgramChange">program change</A> event. Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateRPNChange">MIDIEvent* MIDIEvent_CreateRPNChange <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lCC101, <SPAN CLASS="KEYWORD">long</SPAN> lCC100, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A><BR>(※Unrecommended)</TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lCC101 : CC#101(RPN MSB)'s value (0〜127)<BR>lCC100 : CC#100(RPN LSB)'s value (0〜127)<BR>lVal : CC#6(Data Entry MSB)'s value (0〜127)</TD>
  <TD>Successful : Pointer to CC#101 event<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change CC#101(RPN MSB)</A>, <A HREF="#MIDIEvent_ControlChange">control cahnge CC#100(RPN LSB)</A>, and <A HREF="#MIDIEvent_ControlChange">control change CC#6(Data Entry MSB)</A> event.  Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_CreateNRPNChange">MIDIEvent* MIDIEvent_CreateNRPNChange <BR>(<SPAN CLASS="KEYWORD">long</SPAN> lTime, <SPAN CLASS="KEYWORD">long</SPAN> lCh, <SPAN CLASS="KEYWORD">long</SPAN> lCC99, <SPAN CLASS="KEYWORD">long</SPAN> lCC98, <SPAN CLASS="KEYWORD">long</SPAN> lVal);</A><BR>(※Unrecommended)</TD>
  <TD>lTime : Absolute time<BR>lCh : Channel (0〜15)<BR>lCC99 : CC#99(NRPN MSB)'s value (0〜127)<BR>lCC98 : CC#98(NRPN LSB)'s value (0〜127)<BR>lVal : CC#6(Data Entry MSB)'s value (0〜127)</TD>
  <TD>Successful : Pointer to CC#99 event<BR>Failed : NULL</TD>
  <TD>Create new <A HREF="#MIDIEvent_ControlChange">control change CC#99(NRPN MSB)</A>, <A HREF="#MIDIEvent_ControlChange">control cahnge CC#98(NRPN LSB)</A>, and <A HREF="#MIDIEvent_ControlChange">control change CC#6(Data Entry MSB)</A> event.  Each event is automatically <A HREF="#MIDIEvent_CombinedEvent">combined</A>.</TD>
 </TR>
</TABLE>




<H3><A NAME="MIDIEvent_DeleteFunction">4-5. Delete MIDIEvent</A></H3>

<P> You can delete MIDIEvent on the memory by using MIDIEvent_Delete functions. If parent MIDITrack is deleted by MIDITrack_Delete function, you don't need to delete each MIDIEvent. If parent MIDIData is deleted by MIDIDData_Delete function, you don't need to delete each MIDIEvent.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_DeleteFunctionList">▼List4-5. How to use MIDIEvent_Delete functions</A></DIV>
<PRE>
	...
	<SPAN CLASS="COMMENT">/* Delete MIDIEvent */</SPAN>
	MIDIEvent_Delete (pMIDIEvent);
	pMIDIEvent = NULL;
</PRE>

<P></P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_DeleteFunctionTable">▼Table4-5. Table of MIDIEvent_Delete functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_Delete"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_Delete <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Successful : Number of deleted event (1〜)<BR>Failed : 0</TD>
  <TD>Delete specified MIDIEvent. <SPAN CLASS="RED">If pMIDIEvent is combined such as note on and note off, all combined event are deleted.</SPAN>List pointer is automatically updated.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_DeleteSingle"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_DeleteSingle <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Delete specified MIDIEvent. <SPAN CLASS="RED">If pMIDIEvent is combined such as note on and note off, each event is automatically chopped and remove only one event.</SPAN> List pointer is automatically updated.</TD>
 </TR>
</TABLE>



<H3><A NAME="MIDIEvent_IsFunction">4-6. Check status of MIDIEvent</A></H3>

<P> You can test MIDIEvent's status by using MIDIEvent_Is functions.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_IsFunctionTable">▼Table4-6. Table of MIDIEvent_Is functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsMetaEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsMetaEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_MetaEvent">meta event</A>(0x00〜0x7F).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsSequenceNumber"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsSequenceNumber <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_SequenceNumber">sequence number</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsTextEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsTextEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_TextEvent">text</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsCopyrightNotice"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsCopyrightNotice <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsTrackName"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsTrackName <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_TrackName">sequence name / track name</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsInstrumentName"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsInstrumentName <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_InstrumentName">instrument name</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsLyric"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsLyric <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_Lyric">lyric</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsMarker"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsMarker <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_Marker">marker</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsCuePoint"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsCuePoint <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_TrackName">cue point</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsProgramName"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsProgramName <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_TrackName">program name</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsDeviceName"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsDeviceName <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_DeviceName">device name</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsChannelPrefix"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsChannelPrefix <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsPortPrefix"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsPortPrefix <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_PortPrefix">port prefix</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsEndofTrack"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsEndofTrack <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_TrackName">end of track</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsTempo"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsTempo <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_Tempo">set tempo</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsSMPTEOffset"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsSMPTEOffset <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsTimeSignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsTimeSignature <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_TimeSignature">time signature</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsKeySignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsKeySignature <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_KeySignature">key signature</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsSequencerSpecific"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsSequencerSpecific <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_SequencerSpecific">sequencer specific</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsMIDIEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsMIDIEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsNoteOff"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsNoteOff <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_NoteOff">note off</A> event. Even if pMIDIEvent is note on event, if velocity is 0, this returns yes.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsNoteOn"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsNoteOn <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_NoteOn">note on</A> event. Even if pMIDIEvent is note on event, if velocity is 0, this returns no.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsKeyAftertouch"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsKeyAftertouch <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsProgramChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsProgramChange <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_ProgramChange">program change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsControlChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsControlChange <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_ControlChange">control change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsChannelAftertouch"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsChannelAftertouch <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsPitchBend"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsPitchBend <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsSysExEvent"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsSysExEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_SysExEvent">system exclusive</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsFloating"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsFloating <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_FloatingEvent">floating</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsCombined"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsCombined <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is <A HREF="#MIDIEvent_CombinedEvent">combined</A></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsNoteOnNoteOff"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsNoteOnNoteOff <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is one of the <A HREF="#MIDIEvent_NoteOnNoteOff">note on + note off</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsNoteOnNoteOn0"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsNoteOnNoteOn0 <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is one of the <A HREF="#MIDIEvent_NoteOnNoteOn0">note on + note on 0</A> event.</TD>
 </TR>

 <TR>
  <TD><A NAME="MIDIEvent_IsNote"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsNote <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is one of the <A HREF="#MIDIEvent_NoteOnNoteOff">note on + note off</A> event or one of the <A HREF="#MIDIEvent_NoteOnNoteOn0">note on + note on 0</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsPatchChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsPatchChange <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is one of the <A HREF="#MIDIEvent_PatchChange">patch change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsRPNChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsRPNChange <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is one of the <A HREF="#MIDIEvent_RPNChange">RPN change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_IsNRPNChange"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_IsNRPNChange <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Yes : 1<BR>No : 0</TD>
  <TD>Test whether pMIDIEvent is one of the <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event.</TD>
 </TR>
</TABLE>

<H3><A NAME="MIDIEvent_GetFunction">4-7. Get MIDIEvent's property</A></H3>

<P> You can get MIDIEvent's property by using MIDIEvent_Get functions. Part of functions can be used only for specific kind's event. If event's kind is wrong, return value is undefined.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_GetFunctionTable">▼Talbe4-7. Table of MIDIEvent_Get functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetTime <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Event's time</TD>
  <TD>Get <A HREF="#MIDIEvent_FieldTable">m_lTime</A>'s value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetKind"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetKind <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD><A HREF="#MIDIEvent_Kind">Event's kind</A>(0x00〜0xFF)</TD>
  <TD>Get <A HREF="#MIDIEvent_Kind">m_lKind</A>'s value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetLen"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetLen <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Length of data [bytes]</TD>
  <TD>Get m_lLen's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetData"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetData <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">unsigned char</SPAN>* pData, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pData : Pointer to buffer to write data.<BR>lLen : Length of buffer [bytes]</TD>
  <TD>Writed bytes</TD>
  <TD>Get data directly which m_pData points. </TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetCharCode"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetCharCode <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_NOCHARCODELATIN, MIDIEVENT_NOCHARCODEJP, MIDIEVENT_NOCHARCODEUTF16LE, MIDEVENT_NOCHARCODEUTF16BE, MIDIEVENT_NOCHARCODEUTF8, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE, MIDIEVENT_UTF8)</TD>
  <TD>Get event's char code. This function can be used only for <A HREF="#MIDIEvent_TextEvent">text</A>, <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A>, <A HREF="#MIDIEvent_TrackName">sequence name / track name</A>, <A HREF="#MIDIEvent_InstrumentName">instrument name</A>, <A HREF="#MIDIEvent_Lyric">lyric</A>, <A HREF="#MIDIEvent_Marker">marker</A>, <A HREF="#MIDIEvent_CuePoint">cue point</A>, <A HREF="#MIDIEvent_DeviceName">device name</A>, <A HREF="#MIDIEvent_ProgramName">program name</A> event. If event's data begin with char code idintifier ({@LATIN}, {@JP}, {0xFF, 0xFE}, {0xFE, 0xFF}, {0xEF, 0xBB, 0xBF}), this function returns MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE, MIDIEVENT_UTF8. If the event's data has no char code, but a char code is found in the previous same kind's event in the sequence, this function returns MIDIEVENT_NOCHARCODELATIN, MIDIEVENT_NOCHARCODEJP, MIDIEVENT_NOCHARCODEUTF16LE, MIDIEVENT_NOCHARCODEUTF16BE, MIDIEVENT_NOCHARCODEUTF8. If no char code is found in the sequence, this function returns MIDIEVENT_NOCHARCODE.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetText">TCHAR* MIDIEvent_GetText <BR>(MIDIEvent* pMIDIEvent, TCHAR* pText, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pText : Pointer to buffer to write Text<BR>lLen : Length of buffer [characters]</TD>
  <TD>pBuf</TD>
  <TD>Get event's text. This function can be used only for <A HREF="#MIDIEvent_TextEvent">text</A>, <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A>, <A HREF="#MIDIEvent_TrackName">sequence name / track name</A>, <A HREF="#MIDIEvent_InstrumentName">instrument name</A>, <A HREF="#MIDIEvent_Lyric">lyric</A>, <A HREF="#MIDIEvent_Marker">marker</A>, <A HREF="#MIDIEvent_CuePoint">cue point</A>, <A HREF="#MIDIEvent_DeviceName">device name</A>, <A HREF="#MIDIEvent_ProgramName">program name</A> event. Encoded text is automatically decoded. If the text start with an identifier such as {@LATIN}, {@JP}, {0xFF, 0xFE}, {0xFE, 0xFF}, {0xEF, 0xBB, 0xBF} pText includes the identifier and the text is encoded by the char code. Byte order mark such as {0xFF, 0xFE}, {0xFE, 0xFF}, {0xEF, 0xBB, 0xBF} are converted to {@UTF-16LE}, {@UTF-16BE}, {@UTF-8}.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetTempo"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetTempo <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Tempo [microsec / quarter note]</TD>
  <TD>Get tempo event's tempo data. This function can be used only for <A HREF="#MIDIEvent_Tempo">tempo</A> event. <SPAN CLASS="RED">Be careful that tempo's unit is microsec per quarter note.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetSMPTEOffset"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetSMPTEOffset <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN>* pMode, <SPAN CLASS="KEYWORD">long</SPAN>* pHour, <SPAN CLASS="KEYWORD">long</SPAN>* pMin, <SPAN CLASS="KEYWORD">long</SPAN>* pSec, <SPAN CLASS="KEYWORD">long</SPAN>* pFrame, <SPAN CLASS="KEYWORD">long</SPAN>* pSubFrame);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pMode : Pointer to buffer to write mode (0〜3)<BR>pHour : Pointer to buffer to write hour (0〜23)<BR>pMin : Pointer to buffer to write minutes (0〜59)<BR>pSec : Pointer to buffer to write seconds(0〜59)<BR>pFrame : Pointer to buffer to write frames (0〜30※)<BR>pSubFrame : Pointer to buffer to write subframes (0〜99)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Get SMPTE offset event's each data. This function can be used only for <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A> event. pMode can be MIDIEVENT_SMPTE24(0), MIDIEVENT_SMPTE25(1), MIDIEVENT_SMPTE30D(2), or MIDIEVENT_SMPTE30N(3). pSubFrame's unit is always 1/100 frame.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetTimeSignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetTimeSignature <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN>* pnn, <SPAN CLASS="KEYWORD">long</SPAN>* pdd, <SPAN CLASS="KEYWORD">long</SPAN>* pcc, <SPAN CLASS="KEYWORD">long</SPAN>* pbb);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pnn : Pointer to buffer to write numerator<BR>pdd : Pointer to buffer to write denominator<BR>pcc : Pointer to buffer to write clocks per quarter note<BR>pbb : Pointer to buffer to write demisemiquarvers per quarter note<BR></TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Get time signature event's each data. This function can be used only for <A HREF="#MIDIEvent_TimeSignature">time signature</A> event. pdd is power of 2.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetKeySignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetKeySignature <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN>* psf, <SPAN CLASS="KEYWORD">long</SPAN>* pmi);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>psf : Pointer to buffer to write number of # or ♭<BR>pmi : Pointer to buffer to write major(0) or minor(0)</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Get key signature event's each data. This function can be used only for <A HREF="#MIDIEvent_KeySignature">key signature</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetMIDIMessage"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetMIDIMessage <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">char</SPAN>* pMessage, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pMessage : Pointer to buffer to write message. </TD>
  <TD>Writed bytes</TD>
  <TD>Get MIDI channel event or system exclusive event's message. This function can be used only for MIDI channel event or system exclusive event.This is same as <A HREF="#MIDIEvent_GetData">MIDIEvent_GetData</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetChannel"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetChannel <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Channel (0〜15)</TD>
  <TD>Get MIDI channel event's channel (0〜15). This function can be used only for <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> (= <A HREF="#MIDIEvent_NoteOff">note off</A>, <A HREF="#MIDIEvent_NoteOn">note on</A>, <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A>, <A HREF="#MIDIEvent_ControlChange">control change</A>, <A HREF="#MIDIEvent_ProgramChange">program change</A>, <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A>, <A HREF="#MIDIEvent_PitchBend">pitch bend</A>) event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetKey"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetKey <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent.</TD>
  <TD>Key (0〜127)</TD>
  <TD>Get note off / on or keyaftertouch event's key (0〜127). This function can be used only for <A HREF="#MIDIEvent_NoteOff">note off</A>, <A HREF="#MIDIEvent_NoteOn">note on</A>, <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetVelocity"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetVelocity <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Velocity (0〜127)</TD>
  <TD>Get note off / on event's velocity (0〜127). This function can be used only for <A HREF="#MIDIEvent_NoteOff">note off</A>, <A HREF="#MIDIEvent_NoteOn">note on</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetDuration"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetDuration <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent.</TD>
  <TD>Duration [ticks] or [subframes]</TD>
  <TD>Get note event's duration. This function can be used only for combined one of note event. If this function is used to <A HREF="#MIDIEvent_NoteOn">note on</A> event, duration is positive value. If this function is used to <A HREF="#MIDIEvent_NoteOff">note off</A> event including note on event with velocity 0, duration is negative value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetNumber"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetNumber <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Number (0〜15, 0〜127, 0〜255, 0〜16383, 0〜65535)</TD>
  <TD>Get <A HREF="#MIDIEvent_SequenceNumber">sequence number</A> event's sequence number (0〜65535). Get <A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A> event's channel number (0〜15). Get <A HREF="#MIDIEvent_PortPrefix">port prefix</A> event's port number(0〜255). Get <A HREF="#MIDIEvent_ControlChange">control change</A> event's control number (0〜127). Get <A HREF="#MIDIEvent_ProgramChange">program change</A> event's program number (0〜127).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetValue"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetValue <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Value (0〜15, 0〜127, 0〜255, 0〜16383, 0〜65535)</TD>
  <TD>Get event's value data. This function can be used only for <A HREF="#MIDIEvent_SequenceNumber">sequence number</A>, <A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A>, <A HREF="#MIDIEvent_PortPrefix">port prefix</A>, <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A>, <A HREF="#MIDIEvent_ControlChange">control change</A>, <A HREF="#MIDIEvent_ProgramChange">program change</A>, <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A>, <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event. If pMIDIEvent is <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event, the value is between 0 and 16383, and the middle value is 8192.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetBank"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetBank <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Bank(0〜16383)</TD>
  <TD>Get combined event's bank. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. Patch change's bank's value is (CC#0's value * 128 + CC#32's value). RPN change's bank's value is (CC#101's value * 128 + CC#100's value). NRPN change's bank's value is (CC#99's value * 128 + CC#98's value).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetBankMSB"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetBankMSB <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Bank MSB (0〜127)</TD>
  <TD>Get combined event's bank MSB. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. Patch change event's MSB is CC#0's value. RPN change's MSB is CC#101's value. NRPN change's MSB is CC#99's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetBankLSB"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetBankLSB <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Bank LSB (0〜127)</TD>
  <TD>Get combined event's bank LSB. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. Patch change event's LSB is CC#32's value. RPN change's LSB is CC#100's value. NRPN change's LSB is CC#98's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetDataEntryMSB"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetDataEntryMSB <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Data Entry MSB (CC#6's value)(0〜127)</TD>
  <TD>Get RPN change or NPRN change event's Data Entry MSB (CC#6's value). This function can be used only for one of <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. </TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetPatchNum"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_GetPatchNum <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Program Number(0〜127)</TD>
  <TD>Get patch change event's Program Number. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A> event. </TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetNextEvent">MIDIEvent* MIDIEvent_GetNextEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to next event</TD>
  <TD>Get pointer to next event. If there is no next event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetPrevEvent">MIDIEvent* MIDIEvent_GetPrevEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to previous event</TD>
  <TD>Get pointer to previous event. If there is no previous event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetNextSameKindEvent">MIDIEvent* MIDIEvent_GetNextSameKindEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to next same kind's event</TD>
  <TD>Get pointer to next same kind's event. If there is no next same kind event, returns NULL. </TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetPrevSameKindEvent">MIDIEvent* MIDIEvent_GetPrevSameKindEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to previous same kind's event</TD>
  <TD>Get pointer to previous same kind's event. If there is no previous same kind event, returns NULL.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetFirstCombinedEvent">MIDIEvent* MIDIEvent_GetFirstCombinedEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to the first event in the combined event.</TD>
  <TD>Get pointer to the first event in the <A HREF="#MIDIEvent_CombinedEvent">combined</A> event. If pMIDIEvent is not combined, returns pMIDIEvent.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetLastCombinedEvent">MIDIEvent* MIDIEvent_GetLastCombinedEvent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to the last event in the combined event.</TD>
  <TD>Get pointer to the last event in the <A HREF="#MIDIEvent_CombinedEvent">combined</A> event. If pMIDIEvent is not combined, returns pMIDIEvent.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_GetParent">MIDITrack* MIDIEvent_GetParent <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Pointer to parent MIDITrack</TD>
  <TD>Get pointer to parent MIDITrack. If floating, returns NULL.</TD>
 </TR>
</TABLE>


<H3><A NAME="MIDIEvent_SetFunction">4-8. Set MIDIEvent's property</A></H3>

<P> You can set MIDIEvent's property by using MIDIEvent_Set functions. Part of functions can be used only for specific kind's event. If event's kind is wrong, the result is unexpected and return value is undefined.</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_SetFunctionTable">▼Table4-8. Table of MIDIData_Set functions</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetTime"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetTime <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lTime);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lTime : Absolute time (0〜0x7FFFFFFF)</TD>
  <TD>Successful : Number of midified event (1〜)<BR>Failed ： 0</TD>
  <TD>Set MIDIEvent's <A HREF="#MIDIEvent_FieldTable">time</A>. <SPAN CLASS="RED">If pMIDIEvent belongs to MIDITrack, the event's order in the track is automatically updated. If the MIDITrack has same time's event, pMIDIEvent is moved to the last of same time's event. If lTime is later than <A HREF="#MIDIEvent_EndofTrack">end of track</A> event' s time, end of track event's time is automatically moved to lTime. If pMIDIEvent is combined such as note on and note off, each event's time in the combined event is modified. If pMIDIEvent is combined note event, the duration is kept. So if you need to modify note's duration, you need to use <A HREF="#MIDIEvent_SetDuration">MIDIEvent_SetDuration</A>.</SPAN><BR><SPAN>You must not use this function in <A HREF="#MIDITrack_forEachEvent">forEachEvent</A> or <A HREF="#MIDITrack_forEachEvent">forEachEventInverse</A> scope. If need, you must copy each event's pointer to your local array, and then you should use this function to your local array.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetTimeSingle"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetTimeSingle <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lTime);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lTime : Absolute time (0〜0x7FFFFFFF)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set MIDIEvent's <A HREF="#MIDIEvent_FieldTable">time</A>. This is same as MIDIEvent_SetTime, but even if pMIDIEvent is combined, this function works only to single event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetKind"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetKind <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lKind);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lKind : <A HREF="#MIDIEvent_Kind">MIDIEvent's kind</A></TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Modify <A HREF="#MIDIEvent_Kind">MIDIEvent's kind</A>. lKind must be between MIDIEVENT_SEQUENCENUMBER(0x00) and MIDIEVENT_SYSEXSTART(0xF7). <SPAN CLASS="RED">By using this function, event's data becomes wrong. So you need to set correct data immediately.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetData"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetData <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">char</SPAN>* pData, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIData<BR>pData : Pointer to buffer which has data<BR>lLen : Length of buffer [bytes]</TD>
  <TD>Writed bytes</TD>
  <TD>Set event's data directly. If need, pMIDIEvent's data buffer is automatically allocated. Be careful this function does not check the data is wheter correct or not.</TD></TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetCharCode"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetCharCode <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lCharCode);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lCharCode : Char code (MIDIEVENT_NOCHARCODE, MIDIEVENT_LATIN, MIDIEVENT_JP, MIDIEVENT_UTF16LE, MIDIEVENT_UTF16BE or MIDIEVENT_UTF8)</TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Set event's char code. This function can be used only for <A HREF="#MIDIEvent_TextEvent">text</A>, <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A>, <A HREF="#MIDIEvent_TrackName">sequence name / track name</A>, <A HREF="#MIDIEvent_InstrumentName">instrument name</A>, <A HREF="#MIDIEvent_Lyric">lyric</A>, <A HREF="#MIDIEvent_Marker">marker</A>, <A HREF="#MIDIEvent_CuePoint">cue point</A>, <A HREF="#MIDIEvent_DeviceName">device name</A>, <A HREF="#MIDIEvent_ProgramName">program name</A> event. Event's text is re-encoded by the specified char code and add the new char code identifiedr. If lCharCode is MIDIEVENT_NOCHARCODE, the event's char code identifier is deleted. Be careful that modifing event's char code affects to the following same kind event's char code encoding way in the sequence.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetText"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetText <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">const</SPAN> TCHAR* pszText);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pszText : Pointer to null terminated string<BR></TD>
  <TD>Successful : non 0<BR>Failed : 0</TD>
  <TD>Set event's string. This function can be used only for <A HREF="#MIDIEvent_TextEvent">text</A>, <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A>, <A HREF="#MIDIEvent_TrackName">sequence name / track name</A>, <A HREF="#MIDIEvent_InstrumentName">instrument name</A>, <A HREF="#MIDIEvent_Lyric">lyric</A>, <A HREF="#MIDIEvent_Marker">marker</A>, <A HREF="#MIDIEvent_CuePoint">cue point</A>, <A HREF="#MIDIEvent_DeviceName">device name</A>, <A HREF="#MIDIEvent_ProgramName">program name</A> event. If pszText begin with a char code identifier such as {@LATIN}, {@JP}, {@UTF-16LE}, {@UTF-16BE} and {@UTF-8}, the text is encoded by the specified char code. {@UTF-16LE}, {@UTF-16BE}, {@UTF-8} are converted to {0xFF, 0xFE}, {0xFE, 0xFF}, {0xEF, 0xBB, 0xBF}. If pszText has no char code identifier, the text is encoded by the previous same kind event's char code in the sequence. If there is no char code identifier in the sequence, the text is encoded by the char code specified by MIDIDataLib_SetDefaultCharCode. Be careful that modifing event's char code affects to the following same kind event's char code encoding way in the sequence.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetTempo"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetTempo <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lTempo);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lTempo : Tempo [microsec / quarter note]</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set tempo event's tempo. This function can be used only for <A HREF="#MIDIEvent_Tempo">tempo</A> event. <SPAN CLASS="RED">lTempo's unit is microsec per quarter note.</SPAN></TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetSMPTEOffset">MIDIEvent* MIDIEvent_SetSMPTEOffset <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lMode, <SPAN CLASS="KEYWORD">long</SPAN> lHour, <SPAN CLASS="KEYWORD">long</SPAN> lMin, <SPAN CLASS="KEYWORD">long</SPAN> lSec, <SPAN CLASS="KEYWORD">long</SPAN> lFrame, <SPAN CLASS="KEYWORD">long</SPAN> lSubFrame);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lMode : mode (0〜3)<BR>lHour : Hour(0〜23)<BR>lMin : Minutes(0〜59)<BR>lSec : Seconds(0〜59)<BR>lFrame : Frames(0〜30※)<BR>lSubFrame : SubFrames(0〜99)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set SMPTE offset event's SMPTE offset. This function can be used only for <A HREF="#MIDIEvent_SMPTEOffset">SMPTE offset</A> event. lMode must be MIDIEVENT_SMPTE24(=0), MIDIEVENT_SMPTE25(=1), MIDIEVENT_SMPTE30D(=2), or MIDIEVENT_SMPTE30N(=3). lSubFrame's unit is always 1/100 frame.</TD> </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetTimeSignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetTimeSignature <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lnn, <SPAN CLASS="KEYWORD">long</SPAN> ldd, <SPAN CLASS="KEYWORD">long</SPAN> lcc, <SPAN CLASS="KEYWORD">long</SPAN> lbb);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lnn : Numerator<BR>ldd : Denominator's power<BR>lcc : MIDI clocks per quarter note (=24)<BR>ldd : Demisemiquarvers per quarter note (=8)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set time signature event's time signature. This functin can be used only for <A HREF="#MIDIEvent_TimeSignature">time signature</A> event. ldd is 2's power. </TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetKeySignature"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetKeySignature <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lsf, <SPAN CLASS="KEYWORD">long</SPAN> lmi);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lsf : Number of # or ♭ (-7〜+7)<BR>lmi : Major or Minor(0〜1)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set key signature event's key signature. This function can be used only for <A HREF="#MIDIEvent_KeySignature">key signature</A> event. If lsf is positive, lsf is number of #. If lsf is negative, lsf is number of ♭. If lsf is 0, no # or ♭. lmi must be MIDIEVENT_KEYMAJOR(=0) or MIDIEVENT_KEYMINOR(=1)</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetMIDIMessage"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetMIDIMessage <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">char</SPAN>* pMessage, <SPAN CLASS="KEYWORD">long</SPAN> lLen);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>pData : Pointer to buffer which has MIDI message<BR>lLen : MIDI meeeage's length [bytes]</TD>
  <TD>Writed bytes</TD>
  <TD>Set MIDI channel event or system exclusive event's MIDI message. This is same as MIDIEvent_SetData.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetChannel"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetChannel <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lChannel);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lChannel : Channel(0〜15)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set MIDIEvent's channel. This function can be used only for <A HREF="#MIDIEvent_MIDIChannelEvent">MIDI channel event</A> (=<A HREF="#MIDIEvent_NoteOff">note off</A>, <A HREF="#MIDIEvent_NoteOn">note on</A>, <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A>, <A HREF="#MIDIEvent_ControlChange">control change</A>, <A HREF="#MIDIEvent_ProgramChange">program change</A>, <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A>, <A HREF="#MIDIEvent_PitchBend">pitch bend</A>).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetKey"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetKey <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lKey);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lKey : Key(0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set MIDIEvent's key. This function can be used only for <A HREF="#MIDIEvent_NoteOff">note off</A>, <A HREF="#MIDIEvent_NoteOn">note on</A>, <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetVelocity"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetVelocity <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lVelocity);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lVelocity : Velocity (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set MIDIEvent's velocity. This function can be used only for <A HREF="#MIDIEvent_NoteOff">note off</A>, <A HREF="#MIDIEvent_NoteOn">note on</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetDuration"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetDuration <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lDuration);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lDuration : Duration [ticks] or [subframes]</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set MIDIEvent's duration. This function can be used only for one of combined note event. If pMIDIEvent is <A HREF="#MIDIEvent_NoteOff">note off</A> event, lDuration's value must be negative. If pMIDIEvent is <A HREF="#MIDIEvent_NoteOn">note on</A> event, lDuration's value must be positive.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetNumber"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetNumber <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lNumber);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lNumber : Number (0〜15, 0〜127, 0〜255, 0〜16383, 0〜65535)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set <A HREF="#MIDIEvent_SequenceNumber">sequence number</A> event's sequence number (0〜65535). Get <A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A> event's channel number (0〜15). Get <A HREF="#MIDIEvent_PortPrefix">port prefix</A> event's port number(0〜255). Get <A HREF="#MIDIEvent_ControlChange">control change</A> event's control number (0〜127). Get <A HREF="#MIDIEvent_ProgramChange">program change</A> event's program number (0〜127).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetValue"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetValue <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lValue);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lValue : Value (0〜15, 0〜127, 0〜255, 0〜16383, 0〜65535)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set MIDIEvent's value data. This function can be used only for <A HREF="#MIDIEvent_SequenceNumber">sequence number</A>, <A HREF="#MIDIEvent_ChannelPrefix">channel prefix</A>, <A HREF="#MIDIEvent_PortPrefix">port prefix</A>, <A HREF="#MIDIEvent_KeyAftertouch">key aftertouch</A>, <A HREF="#MIDIEvent_ControlChange">control change</A>, <A HREF="#MIDIEvent_ProgramChange">program change</A>, <A HREF="#MIDIEvent_ChannelAftertouch">channel aftertouch</A>, <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event. If pMIDIEvent is <A HREF="#MIDIEvent_PitchBend">pitch bend</A> event, the value is between 0 and 16383, and the middle value is 8192.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetBank"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetBank <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lBank);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lBank : Bank(0〜16383)</TD>
  <TD>Successful : 2<BR>Failed : 0</TD>
  <TD>Set combined event's bank. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. Patch change's bank's value is (CC#0's value * 128 + CC#32's value). RPN change's bank's value is (CC#101's value * 128 + CC#100's value(. NRPN change's bank's value is (CC#99's value * 128 + CC#98's value).</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetBankMSB"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetBankMSB <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lBankMSB);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lBankMSB : Bank MSB (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set combined event's bank MSB. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. Patch change event's MSB is CC#0's value. RPN change's MSB is CC#101's value. NRPN change's MSB is CC#99's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetBankLSB"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetBankLSB <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lBankLSB);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lBankLSB : Bank LSB (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set combined event's bank LSB. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event. Patch change event's LSB is CC#32's value. RPN change's LSB is CC#100's value. NRPN change's LSB is CC#98's value.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetDataEntryMSB"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetDataEntryMSB <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lDataEntryMSB);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lDataEntryMSB : CC#6's value (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set RPN change or NRPN change event's Data Entry MSB. This function can be used only for one of <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A> event.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_SetPatchNum"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_SetPatchNum <BR>(MIDIEvent* pMIDIEvent, <SPAN CLASS="KEYWORD">long</SPAN> lNum);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent<BR>lNum : Program Number (0〜127)</TD>
  <TD>Successful : 1<BR>Failed : 0</TD>
  <TD>Set patch change event's program number. This function can be used only for one of <A HREF="#MIDIEvent_PatchChange">patch change</A> event.</TD>
 </TR>
</TABLE>



<H3><A NAME="MIDIEvent_OtherFunction">4-9. MIDIEvent's other function</A></H3>

<P>　MIDIイベントに対するその他の関数をここに示す。</P>

<DIV CLASS="TITLE"><A NAME="MIDIEvent_SetFunctionTable">▼Table4-9. Table of MIDIEvent_Other function</A></DIV>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH WIDTH="25%">Syntax</TH>
  <TH WIDTH="25%">Parameters</TH>
  <TH WIDTH="10%">Return Value</TH>
  <TH WIDTH="40%">Remarks</TH>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_Combine"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_Combine <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Succcessful : Number of combined event (1〜3)<BR>Failed : 0</TD>
  <TD>Set MIDIEvent <A HREF="#MIDIEvent_CombinedEvent">combined</A> status. This function can be used only for <A HREF="#MIDIEvent_NoteOn">note on</A>, <A HREF="#MIDIEvent_ProgramChange">program change</A>, <A HREF="#MIDIEvent_ControlChange">control change</A>' CC#6(Data Entry MSB) event. If there is no connectable event such as note off, nothing occur and returns 0. By using this function, each event can be used as <A HREF="#MIDIEvent_NoteOnNoteOff">note on + note off</A>, <A HREF="#MIDIEvent_NoteOnNoteOn0">note on + note on 0</A>, <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A>.</TD>
 </TR>
 <TR>
  <TD><A NAME="MIDIEvent_Chop"><SPAN CLASS="KEYWORD">long</SPAN> MIDIEvent_Chop <BR>(MIDIEvent* pMIDIEvent);</A></TD>
  <TD>pMIDIEvent : Pointer to MIDIEvent</TD>
  <TD>Successful : Number of chopped event (1〜2)<BR>Failed : 0</TD>
  <TD>Set <A HREF="#MIDIEvent_CombinedEvent">combined</A> MIDIEvent uncombined status. This function can be used only for combined event, which is, <A HREF="#MIDIEvent_NoteOnNoteOff">note on + note off</A>, <A HREF="#MIDIEvent_NoteOnNoteOn0">note on + note on 0</A>, <A HREF="#MIDIEvent_PatchChange">patch change</A>, <A HREF="#MIDIEvent_RPNChange">RPN change</A>, <A HREF="#MIDIEvent_NRPNChange">NRPN change</A>.</TD>
 </TR>
</TABLE>











<H2><A NAME="APPENDIX_A">Appendix A F.A.Q.</A></H2>

<P>This section is too outdated, so removed.</P>

<H2><A NAME="APPENDIX_B">Appendix B Note.Key, Drum.Key, Control Change, Program Change(GM) Table</A></H2>

<P>Note.Key : <A HREF="#MIDIEvent_NoteOn">Note on</A>, <A HREF="#MIDIEvent_NoteOff">Note off</A>, <A HREF="#MIDIEvent_KeyAftertouch">Key Aftertouch</A> event's the second byte's value (in case of normal).</P>

<P>Drum.Key : <A HREF="#MIDIEvent_NoteOn">Note on</A>, <A HREF="#MIDIEvent_NoteOff">Note off</A>, <A HREF="#MIDIEvent_KeyAftertouch">Key Aftertouch</A> event's the second byte's value (in case of GM/GS standard drum).</P>

<P>Control Change : <A HREF="#MIDIEvent_ControlChange">Control change</A> event's the second byte's value.</P>

<P>Program Change : <A HREF="#MIDIEvent_ProgramChange">Program change</A> event's the second byte's value (in case of GM).</P>

<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH>Dec</TH>
  <TH>Hex</TH>
  <TH>Note.Key</TH>
  <TH>Drum.Key</TH>
  <TH>Control Change</TH>
  <TH>Program Change</TH>
 </TR>
 <TR>
  <TD>0</TD>
  <TD>0x00</TD>
  <TD>C0</TD>
  <TD>-</TD>
  <TD>Bank Select MSB</TD>
  <TD>Acoustic Grand Piano</TD>
 </TR>
 <TR>
  <TD>1</TD>
  <TD>0x01</TD>
  <TD>C#0=Db0</TD>
  <TD>-</TD>
  <TD>Modulation MSB</TD>
  <TD>Bright Acoustic Piano</TD>
 </TR>
 <TR>
  <TD>2</TD>
  <TD>0x02</TD>
  <TD>D0</TD>
  <TD>-</TD>
  <TD>Breath Controller MSB</TD>
  <TD>Electric Grand Piano</TD>
 </TR>
 <TR>
  <TD>3</TD>
  <TD>0x03</TD>
  <TD>D#0=Eb0</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Honky-tonk Piano</TD>
 </TR>
 <TR>
  <TD>4</TD>
  <TD>0x04</TD>
  <TD>E0</TD>
  <TD>-</TD>
  <TD>Foot Controller MSB</TD>
  <TD>Electric Piano 1</TD>
 </TR>
 <TR>
  <TD>5</TD>
  <TD>0x05</TD>
  <TD>F0</TD>
  <TD>-</TD>
  <TD>Portamento Time MSB</TD>
  <TD>Electric Piano 2</TD>
 </TR>
 <TR>
  <TD>6</TD>
  <TD>0x06</TD>
  <TD>F#0=Gb0</TD>
  <TD>-</TD>
  <TD>Data Entry MSB</TD>
  <TD>Harpsichord</TD>
 </TR>
 <TR>
  <TD>7</TD>
  <TD>0x07</TD>
  <TD>G0</TD>
  <TD>-</TD>
  <TD>Channel Volume MSB</TD>
  <TD>Clavi</TD>
 </TR>
 <TR>
  <TD>8</TD>
  <TD>0x08</TD>
  <TD>G#0=Ab0</TD>
  <TD>-</TD>
  <TD>Balance MSB</TD>
  <TD>Celesta</TD>
 </TR>
 <TR>
  <TD>9</TD>
  <TD>0x09</TD>
  <TD>A0</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Glockenspiel</TD>
 </TR>
 <TR>
  <TD>10</TD>
  <TD>0x0A</TD>
  <TD>A#0=Bb0</TD>
  <TD>-</TD>
  <TD>Pan MSB</TD>
  <TD>Music Box</TD>
 </TR>
 <TR>
  <TD>11</TD>
  <TD>0x0B</TD>
  <TD>B0</TD>
  <TD>-</TD>
  <TD>Expression MSB</TD>
  <TD>Vibraphone</TD>
 </TR>
 <TR>
  <TD>12</TD>
  <TD>0x0C</TD>
  <TD>C1</TD>
  <TD>-</TD>
  <TD>Effect Control 1 MSB</TD>
  <TD>Marimba</TD>
 </TR>
 <TR>
  <TD>13</TD>
  <TD>0x0D</TD>
  <TD>C#1=Db1</TD>
  <TD>-</TD>
  <TD>Effect Control 2 MSB</TD>
  <TD>Xylophone</TD>
 </TR>
 <TR>
  <TD>14</TD>
  <TD>0x0E</TD>
  <TD>D1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Tubular Bells</TD>
 </TR>
 <TR>
  <TD>15</TD>
  <TD>0x0F</TD>
  <TD>D#1=Eb1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Dulcimer</TD>
 </TR>
 <TR>
  <TD>16</TD>
  <TD>0x10</TD>
  <TD>E1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Drawbar Organ</TD>
 </TR>
 <TR>
  <TD>17</TD>
  <TD>0x11</TD>
  <TD>F1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Percussive Organ</TD>
 </TR>
 <TR>
  <TD>18</TD>
  <TD>0x12</TD>
  <TD>F#1=Gb1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Rock Organ</TD>
 </TR>
 <TR>
  <TD>19</TD>
  <TD>0x13</TD>
  <TD>G1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Church Organ</TD>
 </TR>
 <TR>
  <TD>20</TD>
  <TD>0x14</TD>
  <TD>G#1=Ab1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Reed Organ</TD>
 </TR>
 <TR>
  <TD>21</TD>
  <TD>0x15</TD>
  <TD>A1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Accordion</TD>
 </TR>
 <TR>
  <TD>22</TD>
  <TD>0x16</TD>
  <TD>A#1=Bb1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Harmonica</TD>
 </TR>
 <TR>
  <TD>23</TD>
  <TD>0x17</TD>
  <TD>B1</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Tango Accordion</TD>
 </TR>
 <TR>
  <TD>24</TD>
  <TD>0x18</TD>
  <TD>C2</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Acoustic Guitar (nylon)</TD>
 </TR>
 <TR>
  <TD>25</TD>
  <TD>0x19</TD>
  <TD>C#2=Db2</TD>
  <TD>Snare Roll</TD>
  <TD>-</TD>
  <TD>Acoustic Guitar (steel)</TD>
 </TR>
 <TR>
  <TD>26</TD>
  <TD>0x1A</TD>
  <TD>D2</TD>
  <TD>Finger Snap</TD>
  <TD>-</TD>
  <TD>Electric Guitar (jazz)</TD>
 </TR>
 <TR>
  <TD>27</TD>
  <TD>0x1B</TD>
  <TD>D#2=Eb2</TD>
  <TD>High Q</TD>
  <TD>-</TD>
  <TD>Electric Guitar (clean)</TD>
 </TR>
 <TR>
  <TD>28</TD>
  <TD>0x1C</TD>
  <TD>E2</TD>
  <TD>Slap</TD>
  <TD>-</TD>
  <TD>Electric Guitar (muted)</TD>
 </TR>
 <TR>
  <TD>29</TD>
  <TD>0x1D</TD>
  <TD>F2</TD>
  <TD>Scratch Push</TD>
  <TD>-</TD>
  <TD>Overdriven Guitar</TD>
 </TR>
 <TR>
  <TD>30</TD>
  <TD>0x1E</TD>
  <TD>F#2=Gb2</TD>
  <TD>Scratch Pull</TD>
  <TD>-</TD>
  <TD>Distortion Guitar</TD>
 </TR>
 <TR>
  <TD>31</TD>
  <TD>0x1F</TD>
  <TD>G2</TD>
  <TD>Sticks</TD>
  <TD>-</TD>
  <TD>Guitar Harmonics</TD>
 </TR>
 <TR>
  <TD>32</TD>
  <TD>0x20</TD>
  <TD>G#2=Ab2</TD>
  <TD>Square Click</TD>
  <TD>Bank Select LSB</TD>
  <TD>Acoustic Bass</TD>
 </TR>
 <TR>
  <TD>33</TD>
  <TD>0x21</TD>
  <TD>A2</TD>
  <TD>Metronome Click</TD>
  <TD>Modulation LSB</TD>
  <TD>Electric Bass (finger)</TD>
 </TR>
 <TR>
  <TD>34</TD>
  <TD>0x22</TD>
  <TD>A#2=Bb2</TD>
  <TD>Metronome Bell</TD>
  <TD>Breath Controller LSB</TD>
  <TD>Electric Bass (pick)</TD>
 </TR>
 <TR>
  <TD>35</TD>
  <TD>0x23</TD>
  <TD>B2</TD>
  <TD>Standard Kick 2</TD>
  <TD>-</TD>
  <TD>Fretless Bass</TD>
 </TR>
 <TR>
  <TD>36</TD>
  <TD>0x24</TD>
  <TD>C3</TD>
  <TD>Standard Kick 1</TD>
  <TD>Foot Controller LSB</TD>
  <TD>Slap Bass 1</TD>
 </TR>
 <TR>
  <TD>37</TD>
  <TD>0x25</TD>
  <TD>C#3=Db3</TD>
  <TD>Side Stick</TD>
  <TD>Portamento Time LSB</TD>
  <TD>Slap Bass 2</TD>
 </TR>
 <TR>
  <TD>38</TD>
  <TD>0x26</TD>
  <TD>D3</TD>
  <TD>Standard Snare 1</TD>
  <TD>Data Entry LSB</TD>
  <TD>Synth Bass 1</TD>
 </TR>
 <TR>
  <TD>39</TD>
  <TD>0x27</TD>
  <TD>D#3=Eb3</TD>
  <TD>Hand Clap</TD>
  <TD>Channel Volume LSB</TD>
  <TD>Synth Bass 2</TD>
 </TR>
 <TR>
  <TD>40</TD>
  <TD>0x28</TD>
  <TD>E3</TD>
  <TD>Standard Snare 2</TD>
  <TD>Balance LSB</TD>
  <TD>Violin</TD>
 </TR>
 <TR>
  <TD>41</TD>
  <TD>0x29</TD>
  <TD>F3</TD>
  <TD>Low Tom 2</TD>
  <TD>-</TD>
  <TD>Viola</TD>
 </TR>
 <TR>
  <TD>42</TD>
  <TD>0x2A</TD>
  <TD>F#3=Gb3</TD>
  <TD>Closed Hi-hat</TD>
  <TD>Pan LSB</TD>
  <TD>Cello</TD>
 </TR>
 <TR>
  <TD>43</TD>
  <TD>0x2B</TD>
  <TD>G3</TD>
  <TD>Low Tom 1</TD>
  <TD>Expression LSB</TD>
  <TD>Contrabass</TD>
 </TR>
 <TR>
  <TD>44</TD>
  <TD>0x2C</TD>
  <TD>G#3=Ab3</TD>
  <TD>Pedal Hi-hat</TD>
  <TD>Effect Control 1 LSB</TD>
  <TD>Tremolo Strings</TD>
 </TR>
 <TR>
  <TD>45</TD>
  <TD>0x2D</TD>
  <TD>A3</TD>
  <TD>Mid Tom 2</TD>
  <TD>Effect Control 2 LSB</TD>
  <TD>Pizzicato Strings</TD>
 </TR>
 <TR>
  <TD>46</TD>
  <TD>0x2E</TD>
  <TD>A#3=Bb3</TD>
  <TD>Open Hi-hat</TD>
  <TD>-</TD>
  <TD>Orchestral Harp</TD>
 </TR>
 <TR>
  <TD>47</TD>
  <TD>0x2F</TD>
  <TD>B3</TD>
  <TD>Mid Tom 1</TD>
  <TD>-</TD>
  <TD>Timpani</TD>
 </TR>
 <TR>
  <TD>48</TD>
  <TD>0x30</TD>
  <TD>C4</TD>
  <TD>High Tom 2</TD>
  <TD>-</TD>
  <TD>String Ensemble 1</TD>
 </TR>
 <TR>
  <TD>49</TD>
  <TD>0x31</TD>
  <TD>C#4=Db4</TD>
  <TD>Crash Cymbal 1</TD>
  <TD>-</TD>
  <TD>String Ensemble 2</TD>
 </TR>
 <TR>
  <TD>50</TD>
  <TD>0x32</TD>
  <TD>D4</TD>
  <TD>High Tom 1</TD>
  <TD>-</TD>
  <TD>SynthStrings 1</TD>
 </TR>
 <TR>
  <TD>51</TD>
  <TD>0x33</TD>
  <TD>D#4=Eb4</TD>
  <TD>Ride Cymbal 1</TD>
  <TD>-</TD>
  <TD>SynthStrings 2</TD>
 </TR>
 <TR>
  <TD>52</TD>
  <TD>0x34</TD>
  <TD>E4</TD>
  <TD>Chinese Cymbal</TD>
  <TD>-</TD>
  <TD>Choir Aahs</TD>
 </TR>
 <TR>
  <TD>53</TD>
  <TD>0x35</TD>
  <TD>F4</TD>
  <TD>Ride Bell</TD>
  <TD>-</TD>
  <TD>Voice Oohs</TD>
 </TR>
 <TR>
  <TD>54</TD>
  <TD>0x36</TD>
  <TD>F#4=Gb4</TD>
  <TD>Tambourine</TD>
  <TD>-</TD>
  <TD>Synth Vox</TD>
 </TR>
 <TR>
  <TD>55</TD>
  <TD>0x37</TD>
  <TD>G4</TD>
  <TD>Splash Cymbal</TD>
  <TD>-</TD>
  <TD>Orchestra Hit</TD>
 </TR>
 <TR>
  <TD>56</TD>
  <TD>0x38</TD>
  <TD>G#4=Ab4</TD>
  <TD>Cowbell</TD>
  <TD>-</TD>
  <TD>Trumpet</TD>
 </TR>
 <TR>
  <TD>57</TD>
  <TD>0x39</TD>
  <TD>A4</TD>
  <TD>Crash Cymbal 2</TD>
  <TD>-</TD>
  <TD>Trombone</TD>
 </TR>
 <TR>
  <TD>58</TD>
  <TD>0x3A</TD>
  <TD>A#4=Bb4</TD>
  <TD>Vibra-slap</TD>
  <TD>-</TD>
  <TD>Tuba</TD>
 </TR>
 <TR>
  <TD>59</TD>
  <TD>0x3B</TD>
  <TD>B4</TD>
  <TD>Ride Cymbal 2</TD>
  <TD>-</TD>
  <TD>Muted Trumpet</TD>
 </TR>
 <TR>
  <TD>60</TD>
  <TD>0x3C</TD>
  <TD>C5</TD>
  <TD>High Bongo</TD>
  <TD>-</TD>
  <TD>French Horn</TD>
 </TR>
 <TR>
  <TD>61</TD>
  <TD>0x3D</TD>
  <TD>C#5=Db5</TD>
  <TD>Low Bongo</TD>
  <TD>-</TD>
  <TD>Brass Section</TD>
 </TR>
 <TR>
  <TD>62</TD>
  <TD>0x3E</TD>
  <TD>D5</TD>
  <TD>Mute High Conga</TD>
  <TD>-</TD>
  <TD>Synth Brass 1</TD>
 </TR>
 <TR>
  <TD>63</TD>
  <TD>0x3F</TD>
  <TD>D#5=Eb5</TD>
  <TD>Open High Conga</TD>
  <TD>-</TD>
  <TD>Synth Brass 2</TD>
 </TR>
 <TR>
  <TD>64</TD>
  <TD>0x40</TD>
  <TD>E5</TD>
  <TD>Low Conga</TD>
  <TD>Hold Pedal 1</TD>
  <TD>Soprano Sax</TD>
 </TR>
 <TR>
  <TD>65</TD>
  <TD>0x41</TD>
  <TD>F5</TD>
  <TD>High Timbale</TD>
  <TD>Portament Pedal</TD>
  <TD>Alto Sax</TD>
 </TR>
 <TR>
  <TD>66</TD>
  <TD>0x42</TD>
  <TD>F#5=Gb5</TD>
  <TD>Low Timbale</TD>
  <TD>Sostenuto Pedal</TD>
  <TD>Tenor Sax</TD>
 </TR>
 <TR>
  <TD>67</TD>
  <TD>0x43</TD>
  <TD>G5</TD>
  <TD>High Agogo</TD>
  <TD>Soft Pedal</TD>
  <TD>Baritone Sax</TD>
 </TR>
 <TR>
  <TD>68</TD>
  <TD>0x44</TD>
  <TD>G#5=Ab5</TD>
  <TD>Low Agogo</TD>
  <TD>Legato Pedal</TD>
  <TD>Oboe</TD>
 </TR>
 <TR>
  <TD>69</TD>
  <TD>0x45</TD>
  <TD>A5</TD>
  <TD>Cabasa</TD>
  <TD>Hold Pedal 2</TD>
  <TD>English Horn</TD>
 </TR>
 <TR>
  <TD>70</TD>
  <TD>0x46</TD>
  <TD>A#5=Bb5</TD>
  <TD>Maracas</TD>
  <TD>Sound Variation</TD>
  <TD>Bassoon</TD>
 </TR>
 <TR>
  <TD>71</TD>
  <TD>0x47</TD>
  <TD>B5</TD>
  <TD>Short Hi Whistle</TD>
  <TD>Harmonic Contents</TD>
  <TD>Clarinet</TD>
 </TR>
 <TR>
  <TD>72</TD>
  <TD>0x48</TD>
  <TD>C6</TD>
  <TD>Long Low Whistle</TD>
  <TD>Release Time</TD>
  <TD>Piccolo</TD>
 </TR>
 <TR>
  <TD>73</TD>
  <TD>0x49</TD>
  <TD>C#6=Db6</TD>
  <TD>Short Gurio</TD>
  <TD>Attack Time</TD>
  <TD>Flute</TD>
 </TR>
 <TR>
  <TD>74</TD>
  <TD>0x4A</TD>
  <TD>D6</TD>
  <TD>Long Gurio</TD>
  <TD>Brightness</TD>
  <TD>Recorder</TD>
 </TR>
 <TR>
  <TD>75</TD>
  <TD>0x4B</TD>
  <TD>D#6=Eb6</TD>
  <TD>Claves</TD>
  <TD>Decay Time</TD>
  <TD>Pan Flute</TD>
 </TR>
 <TR>
  <TD>76</TD>
  <TD>0x4C</TD>
  <TD>E6</TD>
  <TD>High Wood Block</TD>
  <TD>Vibrato rate</TD>
  <TD>Blown Bottle</TD>
 </TR>
 <TR>
  <TD>77</TD>
  <TD>0x4D</TD>
  <TD>F6</TD>
  <TD>Low Wood Block</TD>
  <TD>Vibrato deapth</TD>
  <TD>Shakuhachi</TD>
 </TR>
 <TR>
  <TD>78</TD>
  <TD>0x4E</TD>
  <TD>F#6=Gb6</TD>
  <TD>Mute Cuica</TD>
  <TD>Vibrato deray</TD>
  <TD>Whistle</TD>
 </TR>
 <TR>
  <TD>79</TD>
  <TD>0x4F</TD>
  <TD>G6</TD>
  <TD>Open Cuica</TD>
  <TD>Sound Controller 10</TD>
  <TD>Ocarina</TD>
 </TR>
 <TR>
  <TD>80</TD>
  <TD>0x50</TD>
  <TD>G#6=Ab6</TD>
  <TD>Mute Triangle</TD>
  <TD>-</TD>
  <TD>Lead 1 (square)</TD>
 </TR>
 <TR>
  <TD>81</TD>
  <TD>0x51</TD>
  <TD>A6</TD>
  <TD>Open Triangle</TD>
  <TD>-</TD>
  <TD>Lead 2 (sawtooth)</TD>
 </TR>
 <TR>
  <TD>82</TD>
  <TD>0x52</TD>
  <TD>A#6=Bb6</TD>
  <TD>Shaker</TD>
  <TD>-</TD>
  <TD>Lead 3 (calliope)</TD>
 </TR>
 <TR>
  <TD>83</TD>
  <TD>0x53</TD>
  <TD>B6</TD>
  <TD>Jingle Bell</TD>
  <TD>-</TD>
  <TD>Lead 4 (chiff)</TD>
 </TR>
 <TR>
  <TD>84</TD>
  <TD>0x54</TD>
  <TD>C7</TD>
  <TD>Bell Tree</TD>
  <TD>Portament Control</TD>
  <TD>Lead 5 (charang)</TD>
 </TR>
 <TR>
  <TD>85</TD>
  <TD>0x55</TD>
  <TD>C#7=Db7</TD>
  <TD>Castanets</TD>
  <TD>-</TD>
  <TD>Lead 6 (voice)</TD>
 </TR>
 <TR>
  <TD>86</TD>
  <TD>0x56</TD>
  <TD>D7</TD>
  <TD>Mute Surdo</TD>
  <TD>-</TD>
  <TD>Lead 7 (fifths)</TD>
 </TR>
 <TR>
  <TD>87</TD>
  <TD>0x57</TD>
  <TD>D#7=Eb7</TD>
  <TD>Open Surdo</TD>
  <TD>-</TD>
  <TD>Lead 8 (bass + lead)</TD>
 </TR>
 <TR>
  <TD>88</TD>
  <TD>0x58</TD>
  <TD>E7</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Pad 1 (new age)</TD>
 </TR>
 <TR>
  <TD>89</TD>
  <TD>0x59</TD>
  <TD>F7</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Pad 2 (warm)</TD>
 </TR>
 <TR>
  <TD>90</TD>
  <TD>0x5A</TD>
  <TD>F#7=Gb7</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Pad 3 (polysynth)</TD>
 </TR>
 <TR>
  <TD>91</TD>
  <TD>0x5B</TD>
  <TD>G7</TD>
  <TD>-</TD>
  <TD>Reverb</TD>
  <TD>Pad 4 (choir)</TD>
 </TR>
 <TR>
  <TD>92</TD>
  <TD>0x5C</TD>
  <TD>G#7=Ab7</TD>
  <TD>-</TD>
  <TD>Effect 2 Depth</TD>
  <TD>Pad 5 (bowed)</TD>
 </TR>
 <TR>
  <TD>93</TD>
  <TD>0x5D</TD>
  <TD>A7</TD>
  <TD>-</TD>
  <TD>Chorus</TD>
  <TD>Pad 6 (metallic)</TD>
 </TR>
 <TR>
  <TD>94</TD>
  <TD>0x5E</TD>
  <TD>A#7=Bb7</TD>
  <TD>-</TD>
  <TD>Effect 4 Depth</TD>
  <TD>Pad 7 (halo)</TD>
 </TR>
 <TR>
  <TD>95</TD>
  <TD>0x5F</TD>
  <TD>B7</TD>
  <TD>-</TD>
  <TD>Effect 5 Depth</TD>
  <TD>Pad 8 (sweep)</TD>
 </TR>
 <TR>
  <TD>96</TD>
  <TD>0x60</TD>
  <TD>C8</TD>
  <TD>-</TD>
  <TD>Data Increment</TD>
  <TD>FX 1 (rain)</TD>
 </TR>
 <TR>
  <TD>97</TD>
  <TD>0x61</TD>
  <TD>C#8=Db8</TD>
  <TD>-</TD>
  <TD>Data Decrement</TD>
  <TD>FX 2 (soundtrack)</TD>
 </TR>
 <TR>
  <TD>98</TD>
  <TD>0x62</TD>
  <TD>D8</TD>
  <TD>-</TD>
  <TD>NRPN LSB</TD>
  <TD>FX 3 (crystal)</TD>
 </TR>
 <TR>
  <TD>99</TD>
  <TD>0x63</TD>
  <TD>D#8=Eb8</TD>
  <TD>-</TD>
  <TD>NRPN MSB</TD>
  <TD>FX 4 (atmosphere)</TD>
 </TR>
 <TR>
  <TD>100</TD>
  <TD>0x64</TD>
  <TD>E8</TD>
  <TD>-</TD>
  <TD>RPN LSB</TD>
  <TD>FX 5 (brightness)</TD>
 </TR>
 <TR>
  <TD>101</TD>
  <TD>0x65</TD>
  <TD>F8</TD>
  <TD>-</TD>
  <TD>RPN MSB</TD>
  <TD>FX 6 (goblins)</TD>
 </TR>
 <TR>
  <TD>102</TD>
  <TD>0x66</TD>
  <TD>F#8=Gb8</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>FX 7 (echoes)</TD>
 </TR>
 <TR>
  <TD>103</TD>
  <TD>0x67</TD>
  <TD>G8</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>FX 8 (sci-fi)</TD>
 </TR>
 <TR>
  <TD>104</TD>
  <TD>0x68</TD>
  <TD>G#8=Ab8</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Sitar</TD>
 </TR>
 <TR>
  <TD>105</TD>
  <TD>0x69</TD>
  <TD>A8</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Banjo</TD>
 </TR>
 <TR>
  <TD>106</TD>
  <TD>0x6A</TD>
  <TD>A#8=Bb8</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Shamisen</TD>
 </TR>
 <TR>
  <TD>107</TD>
  <TD>0x6B</TD>
  <TD>B8</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Koto</TD>
 </TR>
 <TR>
  <TD>108</TD>
  <TD>0x6C</TD>
  <TD>C9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Kalimba</TD>
 </TR>
 <TR>
  <TD>109</TD>
  <TD>0x6D</TD>
  <TD>C#9=Db9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Bag pipe</TD>
 </TR>
 <TR>
  <TD>110</TD>
  <TD>0x6E</TD>
  <TD>D9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Fiddle</TD>
 </TR>
 <TR>
  <TD>111</TD>
  <TD>0x6F</TD>
  <TD>D#9=Eb9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Shanai</TD>
 </TR>
 <TR>
  <TD>112</TD>
  <TD>0x70</TD>
  <TD>E9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Tinkle Bell</TD>
 </TR>
 <TR>
  <TD>113</TD>
  <TD>0x71</TD>
  <TD>F9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Agogo</TD>
 </TR>
 <TR>
  <TD>114</TD>
  <TD>0x72</TD>
  <TD>F#9=Gb9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Steel Drums</TD>
 </TR>
 <TR>
  <TD>115</TD>
  <TD>0x73</TD>
  <TD>G9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Woodblock</TD>
 </TR>
 <TR>
  <TD>116</TD>
  <TD>0x74</TD>
  <TD>G#9=Ab9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Taiko</TD>
 </TR>
 <TR>
  <TD>117</TD>
  <TD>0x75</TD>
  <TD>A9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Melodic Tom</TD>
 </TR>
 <TR>
  <TD>118</TD>
  <TD>0x76</TD>
  <TD>A#9=Bb9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Synth Drum</TD>
 </TR>
 <TR>
  <TD>119</TD>
  <TD>0x77</TD>
  <TD>B9</TD>
  <TD>-</TD>
  <TD>-</TD>
  <TD>Reverse Cymbal</TD>
 </TR>
 <TR>
  <TD>120</TD>
  <TD>0x78</TD>
  <TD>C10</TD>
  <TD>-</TD>
  <TD>All Sound Off</TD>
  <TD>Guitar Fret Noise</TD>
 </TR>
 <TR>
  <TD>121</TD>
  <TD>0x79</TD>
  <TD>C#10=Db10</TD>
  <TD>-</TD>
  <TD>Reset All Controller</TD>
  <TD>Breath Noise</TD>
 </TR>
 <TR>
  <TD>122</TD>
  <TD>0x7A</TD>
  <TD>D10</TD>
  <TD>-</TD>
  <TD>Local Control</TD>
  <TD>Seashore</TD>
 </TR>
 <TR>
  <TD>123</TD>
  <TD>0x7B</TD>
  <TD>D#10=Eb10</TD>
  <TD>-</TD>
  <TD>All Note Off</TD>
  <TD>Bird Tweet</TD>
 </TR>
 <TR>
  <TD>124</TD>
  <TD>0x7C</TD>
  
  <TD>E10</TD>
  <TD>-</TD>
  <TD>Omni Mode Off</TD>
  <TD>Telephone Ring</TD>
 </TR>
 <TR>
  <TD>125</TD>
  <TD>0x7D</TD>
  <TD>F10</TD>
  <TD>-</TD>
  <TD>Omni Mode On</TD>
  <TD>Helicopter</TD>
 </TR>
 <TR>
  <TD>126</TD>
  <TD>0x7E</TD>
  <TD>F#10=Gb10</TD>
  <TD>-</TD>
  <TD>Mono Mode On</TD>
  <TD>Applause</TD>
 </TR>
 <TR>
  <TD>127</TD>
  <TD>0x7F</TD>
  <TD>G10</TD>
  <TD>-</TD>
  <TD>Poly Mode On</TD>
  <TD>Gunshot</TD>
 </TR>
</TABLE>

<H2><A NAME="APPENDIX_C">Appendix C MIDIEvent_Get/Set Function support</A></H2>
<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH ROWSPAN=2>Function<BR>(omit MIDIEvent_)</TH>
  <TH COLSPAN=18>Meta Event</TH>
  <TH COLSPAN=7>MIDI Channel Event</TH>
  <TH ROWSPAN=2>S<BR>y<BR>s<BR>t<BR>e<BR>m<BR>E<BR>x<BR>c<BR>l<BR>u<BR>s <BR>i<BR>v<BR>e<BR>E<BR>v<BR>e<BR>n<BR>t</TH>
  <TH COLSPAN=4>(Combined)</TH>
 </TR>
 <TR>
  <TH>S<BR>e<BR>q<BR>u<BR>e<BR>n<BR>c<BR>e<BR> N<BR>u<BR>m<BR>b<BR>e<BR>r</TH>
  <TH>T<BR>e<BR>x<BR>t</TH>
  <TH>C<BR>o<BR>p<BR>y<BR>r<BR>i<BR>g<BR>h<BR>t<BR> N<BR>o<BR>t<BR>i<BR>c<BR>e</TH>
  <TH>T<BR>r<BR>a<BR>c<BR>k<BR>N<BR>a<BR>m<BR>e</TH>
  <TH>I<BR>n<BR>s<BR>t<BR>r<BR>u<BR>m<BR>e<BR>n<BR>t<BR>N<BR>a<BR>m<BR>e</TH>
  <TH>L<BR>y<BR>r<BR>i<BR>c</TH>
  <TH>M<BR>a<BR>r<BR>k<BR>e<BR>r</TH>
  <TH>C<BR>u<BR>e<BR> P<BR>o<BR>i<BR>n<BR>t</TH>
  <TH>P<BR>r<BR>o<BR>g<BR>r<BR>a<BR>m<BR>N<BR>a<BR>m<BR>e</TH>
  <TH>D<BR>e<BR>v<BR>i<BR>c<BR>e<BR>N<BR>a<BR>m<BR>e</TH>
  <TH>C<BR>h<BR>a<BR>n<BR>n<BR>e<BR>l<BR>P<BR>r<BR>e<BR>f<BR>i<BR>x</TH>
  <TH>P<BR>o<BR>r<BR>t<BR>P<BR>r<BR>e<BR>f<BR>i<BR>x</TH>
  <TH>E<BR>n<BR>d<BR>o<BR>f<BR>T<BR>r<BR>a<BR>c<BR>k</TH>
  <TH>T<BR>e<BR>m<BR>p<BR>o</TH>
  <TH>S<BR>M<BR>P<BR>T<BR>E<BR>O<BR>f<BR>f<BR>s<BR>e<BR>t</TH>
  <TH>T<BR>i<BR>m<BR>e<BR>S<BR>i<BR>g<BR>n<BR>a<BR>t<BR>u<BR>r<BR>e</TH>
  <TH>K<BR>e<BR>y<BR>S<BR>i<BR>g<BR>n<BR>a<BR>t<BR>u<BR>r<BR>e</TH>
  <TH>S<BR>e<BR>q<BR>u<BR>e<BR>n<BR>c<BR>e<BR>r<BR>S<BR>p<BR>e<BR>c<BR>i<BR>f<BR>i<BR>c</TH>
  <TH>N<BR>o<BR>t<BR>e<BR>O<BR>f<BR>f</TH>
  <TH>N<BR>o<BR>t<BR>e<BR>O<BR>n</TH>
  <TH>K<BR>e<BR>y<BR>A<BR>f<BR>t<BR>e<BR>r<BR>t<BR>o<BR>u<BR>c<BR>h</TH>
  <TH>C<BR>o<BR>n<BR>t<BR>r<BR>o<BR>l<BR>C<BR>h<BR>a<BR>n<BR>g<BR>e</TH>
  <TH>P<BR>r<BR>o<BR>g<BR>r<BR>a<BR>m<BR>C<BR>h<BR>a<BR>n<BR>g<BR>e</TH>
  <TH>C<BR>h<BR>a<BR>n<BR>n<BR>e<BR>l<BR>A<BR>f<BR>t<BR>e<BR>r<BR>t<BR>o<BR>u<BR>c<BR>h</TH>
  <TH>P<BR>i<BR>t<BR>c<BR>h<BR>B<BR>e<BR>n<BR>d</TH>
  <TH>N<BR>o<BR>t<BR>e</TH>
  <TH>P<BR>a<BR>t<BR>c<BR>h<BR>C<BR>h<BR>a<BR>n<BR>g<BR>e</TH>
  <TH>R<BR>P<BR>N<BR>C<BR>h<BR>a<BR>n<BR>g<BR>e</TH>
  <TH>N<BR>R<BR>P<BR>N<BR>C<BR>h<BR>a<BR>n<BR>g<BR>e</TH>
 </TR>
 <TR>
  <TD>GetTime<BR>SetTime</TD>
  <TD>○<BR>1</TD>
  <TD>○</TD>
  <TD>○<BR>1</TD>
  <TD>○<BR>1</TD>
  <TD>○<BR>1</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○<BR>2</TD>
  <TD>○</TD>
  <TD>○<BR>1</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○<BR>3</TD>
  <TD>○<BR>4</TD>
  <TD>○<BR>4</TD>
  <TD>○<BR>4</TD>
 </TR>
 <TR>
  <TD>GetKind<BR>SetKind</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○<BR>5</TD>
  <TD>○<BR>5</TD>
  <TD>○<BR>5</TD>
  <TD>○<BR>5</TD>
 </TR>
 <TR>
  <TD>GetLen</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
 </TR>
 <TR>
  <TD>GetData<BR>SetData</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
 </TR>
 <TR>
  <TD>GetText<BR>SetText</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetTempo<BR>SetTempo</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetSMPTEOffset<BR>SetSMPTEOffset</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetTimeSignature<BR>SetTimeSignature</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetKeySignature<BR>SetKeySignature</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetMIDIMessage<BR>SetMIDIMessage</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
  <TD>○<BR>6</TD>
 </TR>
 <TR>
  <TD>GetChannel<BR>SetChannel</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
 </TR>
 <TR>
  <TD>GetKey<BR>SetKey</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetVelocity<BR>SetVelocity</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetDuration<BR>SetDuration</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○7</TD>
  <TD>○7</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetNumber<BR>SetNumber</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
 </TR>
 <TR>
  <TD>GetValue<BR>SetValue</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
 </TR>
 <TR>
  <TD>GetBank<BR>SetBank</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
 </TR>
 <TR>
  <TD>GetBankMSB<BR>SetBankMSB</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
 </TR>
 <TR>
  <TD>GetBankLSB<BR>SetBankLSB</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>×</TD>
  <TD>○</TD>
  <TD>○</TD>
  <TD>○</TD>
 </TR>
</TABLE>
<DIV>※1 : These event must be put at time 0.</DIV>
<DIV>※2 : End of track event's time must be the last in the track.</DIV>
<DIV>※3 : If used to note on event, for keeping duration, note off event is also moved. If used to note off event, for keeping duration, note on event is also moved.</DIV>
<DIV>※4 : If used SetTime, each combined event's time is moved.</DIV>
<DIV>※5 : GetKind returns single event's kind, not returns other combined event's kind. SetKind can convert event's kind single to multiple-combined or multiple-combined to single event.</DIV>
<DIV>※6 : GetData/SetData works to single event, not works to other combined event.</DIV>
<DIV>※7 : If note on and note off is not combined, GetDuration returns 0 and SetDuration does nothing.</DIV>



<H2><A NAME="APPENDIX_D">Appendix D History</A></H2>

<TABLE WIDTH="100%" BORDER=1 CELLSPACING=1 CELLPADDING=2>
 <TR>
  <TH>
   Version
  </TH>
  <TH>
   Release day
  </TH>
  <TH>
   Remarks
  </TH>
 </TR>
 <TR>
  <TD>
   β0.1
  </TD>
  <TD>
   2004/6/20
  </TD>
  <TD>
   <UL>
    <LI>The first relase with many bug.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.2
  </TD>
  <TD>
   2004/7/20
  </TD>
  <TD>
   <UL>
    <LI>A bug that this can't be used from C++ is fixed.</LI>
    <LI>A bug of MIDITrack_MakeTime and MIDITrack_BreakTime is fixed.</LI>
    <LI>MIDITrack_MakeTimeEx and MIDITrack_BreakTimeEx is added.</LI>
    <LI>MIDIEvent_IsNote's specification is defined.</LI>
    <LI>MIDIEvent_DeleteSingle is released.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.3
  </TD>
  <TD>
   2004/12/19
  </TD>
  <TD>
   <UL>
    <LI>A bug that in MIDIData_SetFormat, it can't convert format0 to format1 is fixed.</LI>
    <LI>MIDITrack_GetName and MIDITrack_SetName are released.</LI>
    <LI>MIDITrack_GetFirstKindEvent and MIDITrack_GetLastKindEvent are released.</LI>
    <LI>MIDITrack_GetNextSameKindEvent and MIDITrack_GetPrevSameKindEvent released</LI>
    <LI>A bug that setting blank text causes error is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.4
  </TD>
  <TD>
   2005/01/15
  </TD>
  <TD>
   <UL>
    <LI>MIDITrack_GetParent and MIDIEvent_GetParent are added.</LI>
    <LI>This guide's MIDIEVENT_TRACKNAME and MIDIEVENT_COPYRIGHTNOTICE are fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.5
  </TD>
  <TD>
   2005/04/23
  </TD>
  <TD>
   <UL>
    <LI>MIDITrack_FindTimeSignature and MIDIEvent_FindKeyParent are added.</LI>
    <LI>m_lUser3 are added to MIDIData structure, MIDITrack structure, MIDIEvent structure.</LI>
    <LI>SMF読み込み時、結合できるイベントは自動結合するようにした</LI>
    <LI>A bug of MIDIEvent_GetBank and MIDIEvent_SetBank is fixed.</LI>
    <LI>MIDIEvent_GetBankMSB and MIDIEvent_GetBankLSB are added.</LI>
    <LI>MIDIEvent_SetBankMSB and MIDIEvent_SetBankLSB are added.</LI>
    <LI>Appendix C is added to this guide.</LI>
    <LI>This guide's MIDIEvent_GetVelocity and MIDIEvent_SetVelocity are fixed</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.6
  </TD>
  <TD>
   2005/09/18
  </TD>
  <TD>
   <UL>
    <LI>Add lacked fanction to MIDIData.bas</LI>
    <LI>MIDIEvent_GetMIDIMessage and MIDIEvent_SetMIDIMessage are added.</LI>
    <LI>Part of this guide is fixed,</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.7
  </TD>
  <TD>
   2007/01/18日
  </TD>
  <TD>
   <UL>
    <LI>A bug MIDIEvent_GetData function is fixed.</LI>
    <LI>MIDIData_TimeToMillisec is added.</LI>
    <LI>MIDIData_MillisecToTime is added.</LI>
    <LI>MIDIData_MakeTime is added.</LI>
    <LI>MIDIData_MakeTimeEx is added.</LI>
    <LI>MIDIData_BreakTime is added.</LI>
    <LI>MIDIData_BreakTimeEx is added.</LI>
    <LI>MIDIData_FindTempo is added.</LI>
    <LI>MIDIData_FindTimeSignature is added.</LI>
    <LI>MIDIData_FindKeySignature is added.</LI>
    <LI>MIDITrack_FindTempo is added.</LI>
    <LI>Part of this guide is fixed.</LI>
    <LI>Project web site is moved to yahoo geocities.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.8
  </TD>
  <TD>
   2007/12/28
  </TD>
  <TD>
   <UL>
    <LI>A bug of MIDIData_MakeTime is fixed.</LI>
    <LI>A bug of MIDITrack_MakeTime is fixed.</LI>
    <LI>A bug of MIDIEvent_SetFloating (concealed) is fixed.</LI>
    <LI>A bug of MIDIEvent_SetPrevEvent (concealed) is fixed.</LI>
    <LI>A bug of MIDIEvent_SetNextEvent (concealed) is fixed.</LI>
    <LI>A bug of MIDIEvent_SetTimeSingle (concealed) is fixed.</LI>
    <LI>A bug of MIDIEvent_SetKindSingle (concealed) is fixed.</LI>
    <LI>A bug of MIDIEvent_SetKind is fixed.</LI>
    <LI>A bug of MIDIEvent_SetChannel is fixed.</LI>
    <LI>A specification of MIDIEvent_CreateClone is modified.</LI>
    <LI>A bug of MIDIEvent_GetNumber is fixed.</LI>
    <LI>A bug of MIDIEvent_SetNumber is fixed.</LI>
    <LI>A bug of MIDIEvent_GetValue is fixed.</LI>
    <LI>A bug of MIDIEvent_SetValue is fixed.</LI>
    <LI>MIDIEvent_Combine is added.</LI>
    <LI>MIDIEvent_Chop is added.</LI>
    <LI>A bug of MIDITrack_FindTimeSignature is fixed.</LI>
    <LI>MIDITrack_Create's specification is modified.</LI>
    <LI>MIDIData_TimeToMillisec corresponds to SMAPTE base.</LI>
    <LI>MIDIData_MillisecToTime correponds to SMPTE base.</LI>
    <LI>A bug of MIDIData_SetFormat is fixed.</LI>
    <LI>A bug that MIDIData_SaveAsSMF may omit part of running status is fixed.</LI>
    <LI>MIDIData_Load is modified to MIDIData_LoadFromSMF</LI>
    <LI>MIDIData_Save is modified to MIDIData_SaveAsSMF</LI>
    <LI>MIDIData_LoadFromBirnay is added.</LI>
    <LI>MIDIData_SaveAsBinary is added.</LI>
    <LI>A specification that MIDIData_LoadFromSMF combines note on and note off automatically is abolished.</LI>
    <LI>Part of this guide is fixed.</LI>
    <LI>This guide corresponds to W3C HTML4.01.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   β0.9
  </TD>
  <TD>
   2008/03/31
  </TD>
  <TD>
   <UL>
    <LI>Project web site is moved to sourceforge.jp (<A HREF="https://openmidiproject.osdn.jp/index.html">https://openmidiproject.osdn.jp/index.html</A>).</LI>
    <LI>MIN, MAX, CLIP macro is added.</LI>
    <LI>A specification that <A HREF="#MIDIEvent_Combine">MIDIEvent_Combine</A> is not applied to note off event is modified.</LI>
    <LI>A bug that <A HREF="#MIDIData_SetFormat">MIDIData_SetFormat</A> fortets add end of track event when converting format0 to format1/2 is fixed.</LI>
    <LI><A HREF="#MIDIData_MakeTime">MIDIData_MakeTime</A>, <A HREF="#MIDIData_MakeTimeEx">MIDIData_MakeTimeEx</A>, <A HREF="#MIDITrack_MakeTime">MIDITrack_MakeTime</A>, and <A HREF="#MIDITrack_MakeTimeEx">MIDITrack_MakeTimeEx</A> correspond to SMPTE base's MIDIData.</LI>
    <LI><A HREF="#MIDIData_BreakTime">MIDIData_BreakTime</A>, <A HREF="#MIDIData_BreakTimeEx">MIDIData_BreakTimeEx</A>, <A HREF="#MIDITrack_BreakTime">MIDITrack_BreakTime</A>, and <A HREF="#MIDITrack_BreakTimeEx">MIDITrack_BreakTimeEx</A> correspond to SMPTE base's MIDIData.</LI>
    <LI>MIDIData_Merge is added as a test function.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.0
  </TD>
  <TD>
   2008/07/26
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDITrack_GetNextTrack">MIDITrack_GetNextTrack</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetPrevTrack">MIDITrack_GetPrevTrack</A> is added.</LI>
    <LI>MIDITrack_GetNextEvent is abolished. Instead, use (<A HREF="#MIDIEvent_GetNextEvent">MIDIEvent_GetNextEvent</A>.</LI>
    <LI>MIDITrack_GetPrevEvent is abolished. Instead, use (<A HREF="#MIDIEvent_GetPrevEvent">MIDIEvent_GetPrevEvent</A>.</LI>
    <LI>MIDITrack_GetNextSameKindEvent is ablished. Instead, use (<A HREF="#MIDIEvent_GetNextSameKindEvent">MIDIEvent_GetNextSameKindEvent</A>.</LI>
    <LI>MIDITrack_GetPrevSameKindEvent is ablished. Instead, use (<A HREF="#MIDIEvent_GetPrevSameKindEvent">MIDIEvent_GetPrevSameKindEvent</A>.</LI>
    <LI>A specification of MIDIEvent_SetPrevEvent (concealed) is modified.</LI>
    <LI>A specification of MIDIEvent_SetNextEvent (concealed) is modified.</LI>
    <LI>A specification of <A HREF="#MIDIEvent_SetTimeSingle">MIDIEvent_SetTimeSingle</A> is modified.</LI>
    <LI>MIDIData_Merge is ablished</LI>
    <LI><A HREF="#MIDIData_SetFormat">MIDIData_SetFormat</A> correspond to format2.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.1
  </TD>
  <TD>
   2008/08/16
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDIEvent_SetChannel">MIDIEvent_SetChannel</A> forget updating m_pNextSameKindEvent and m_pPrevSameKindEvent is fixed.</LI>
    <LI>MIDIData.bas is totally updated.</LI>
    <LI>In this guide, <A HREF="#MIDIEvent_GetNextSameKindEvent">MIDIEvent_GetNextSameKindEvent</A>'s remarks is fixed.</LI>
    <LI>In this guide, <A HREF="#MIDIEvent_GetPrevSameKindEvent">MIDIEvent_GetPrevSameKindEvent</A>'s remarks is fixed.</LI>
    <LI>In this guide, <A HREF="#MIDIData_GetTimeBase">MIDIData_GetTimeBase</A> is added.</LI>
    <LI>In this guide, <A HREF="#MIDITrack_CheckSetupTrack">MIDITrack_CheckSetupTrack</A> is added.</LI>
    <LI>In this guide, <A HREF="#MIDITrack_CheckNonSetupTrack">MIDITrack_CheckNonSetupTrack</A> is added.</LI>
    <LI>In this guide, other wrong description is fixed.</LI>
    </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.2
  </TD>
  <TD>
   2008/09/20
  </TD>
  <TD>
   <UL>
    <LI>A bug of <A HREF="#MIDITrack_MillisecToTime">MIDITrack_MillisecToTime</A> is fixed. A bug of <A HREF="#MIDIData_MillisecToTime">MIDIData_MillisecToTime</A> is also fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.3
  </TD>
  <TD>
   2008/10/07
  </TD>
  <TD>
   <UL>
    <LI>In this guide, <A HREF="#MIDIData_CountTrack">MIDIData_CountTrack</A> is added.</LI>
    <LI>In this guide, <A HREF="#MIDITrack_CountEvent">MIDITrack_CountEvent</A> is added.</LI>
    <LI>In this guide, <A HREF="#MIDITrack_RemoveEvent">MIDITrack_RemoveEvent</A> is fixed.</LI>
    <LI>In this guide, <A HREF="#MIDITrack_RemoveSingleEvent">MIDITrack_RemoveSingleEvent</A> is added.</LI>
    <LI>In this guide, <A HREF="#MIDIEvent_Delete">MIDIEvent_Delete</A> is fixed.</LI>
    <LI>In this guide, <A HREF="#MIDIEvent_DeleteSingle">MIDIEvent_DeleteSingle</A> is added.</LI>
    <LI>In this guide, <A HREF="#MIDIEvent_SetTime">MIDIEvent_SetTime</A> is fixed.</LI>
    <LI>In this guide, <A HREF="#MIDIEvent_SetTimeSingle">MIDIEvent_SetTimeSingle</A> is added.</LI>
    <LI>In this guide, <A HREF="#forEachTrack">forEachTrack</A> macro is added and fixed.</LI>
    <LI>In this guide, <A HREF="#forEachEvent">forEachEvent</A> macro is added and fixed.</LI>
    <LI>In this guide, other wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.4
  </TD>
  <TD>
   2008/11/03
  </TD>
  <TD>
   <UL>
    <LI>Correspond to Cherry sequence file (*.chy) load / save.</LI>
    <LI><A HREF="#MIDIData_LoadFromCherry">MIDIData_LoadFromCherry</A> is added.</LI>
    <LI><A HREF="#MIDIData_SaveAsCherry">MIDIData_SaveAsCherry</A> is added.</LI>
    <LI>m_lInputOn, m_lInputPort, m_lInputChannel, m_lOutputOn, m_lOutputPort, m_lOutputChannel, m_lTimePlus, m_lKeyPlus, m_lVelocityPlus, m_lViewMode, m_lForeColor, m_lBackColor are adde to <A HREF="#MIDITrack_FieldTable">MIDITrack</A> structure.</LI>
    <LI><A HREF="#MIDIData_LoadFromBinary">MIDIData_LoadFromBinary</A> is updated to version "MDa2".</LI>
    <LI><A HREF="#MIDIData_SaveAsBinary">MIDIData_SaveAsBinary</A> is updated to version "MDa2".</LI>
    <LI><A HREF="#MIDITrack_GetInputOn">MIDITrack_GetInputOn</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetInputPort">MIDITrack_GetInputPort</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetInputChannel">MIDITrack_GetInputChannel</A>is added.</LI>
    <LI><A HREF="#MIDITrack_GetOutputOn">MIDITrack_GetOutputOn</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetOutputPort">MIDITrack_GetOutputPort</A>is added.</LI>
    <LI><A HREF="#MIDITrack_GetOutputChannel">MIDITrack_GetOutputChannel</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetTimePlus">MIDITrack_GetTimePlus</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetKeyPlus">MIDITrack_GetKeyPlus</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetVelocityPlus">MIDITrack_GetVelocityPlus</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetViewMode">MIDITrack_GetViewMode</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetForeColor">MIDITrack_GetForeColor</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetBackColor">MIDITrack_GetBackColor</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetInputOn">MIDITrack_SetInputOn</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetInputPort">MIDITrack_SetInputPort</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetInputChannel">MIDITrack_SetInputChannel</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetOutputOn">MIDITrack_SetOutputOn</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetOutputPort">MIDITrack_SetOutputPort</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetOutputChannel">MIDITrack_SetOutputChannel</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetTimePlus">MIDITrack_SetTimePlus</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetKeyPlus">MIDITrack_SetKeyPlus</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetVelocityPlus">MIDITrack_SetVelocityPlus</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetViewMode">MIDITrack_SetViewMode</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetForeColor">MIDITrack_SetForeColor</A> is added.</LI>
    <LI><A HREF="#MIDITrack_SetBackColor">MIDITrack_SetBackColor</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetBeginTime">MIDITrack_GetBeginTime</A> is added.</LI>
    <LI><A HREF="#MIDITrack_GetEndTime">MIDITrack_GetEndTime</A> is added.</LI>
    <LI>A bug that <A HREF="#MIDIData_SaveAsSMF">MIDIData_SaveAsSMF</A> (MIDITrack_SaveAsSMF) delete preceding space is fixed.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.5
  </TD>
  <TD>
   2008/12/13
  </TD>
  <TD>
   <UL>
    <LI>Correspond to Cherry sequence file(*.chy)'s virtual control change.</LI>
    <LI>A specification of <A HREF="#MIDITrack_InsertEventBefore">MIDITrack_InsertEventBefore</A> when failed is modified.</LI>
    <LI>A specification of <A HREF="#MIDITrack_InsertEventAfter">MIDITrack_InsertEventAfter</A> when failed is modified.</LI>
    <LI>A specification of <A HREF="#MIDITrack_InsertEvent">MIDITrack_InsertEvent</A> when failed is modified.</LI>
    <LI>A specification of <A HREF="#MIDIEvent_CreateClone">MIDIEvent_CreateClone</A> is modified.</LI>
    <LI><A HREF="#MIDITrack_CreateClone">MIDITrack_CreateClone</A> is added.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.6
  </TD>
  <TD>
   2008/12/20
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIData_SetFormat">MIDIData_SetFormat</A> is modified to automatically update each track's input port, input channel, output port, output channel, and view mode.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.7
  </TD>
  <TD>
   2008/12/27
  </TD>
  <TD>
   <UL>
    <LI>A bug of <A HREF="#MIDIEvent_CreateSMPTEOffset">MIDIEvent_CreateSMPTEOffset</A> is fixed.</LI>
    <LI>A bug of <A HREF="#MIDIEvent_SetSMPTEOffset">MIDIEvent_SetSMPTEOffset</A> is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIEvent_SetKind">MIDIEvent_SetKind</A> convert to wrong SMPTE offset event is fixed.</LI>
    <LI>A bug of <A HREF="#MIDIEvent_IsSequencerSpecific">MIDIEvent_IsSequencerSpecific</A> is fixed.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.8
  </TD>
  <TD>
   2009/01/17
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDITrack_InsertEvent">MIDITrack_InsertEvent</A> may put note off before note on is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_SetFormat">MIDIEvent_SetFormat</A> may put note off before note on is fixed.</LI>
    <LI><A HREF="#MIDITrack_GetXFVersion">MIDITrack_GetXFVersion</A> is added.</LI>
    <LI><A HREF="#MIDIData_GetXFVersion">MIDIData_GetXFVersion</A> is added.</LI>
    <LI><A HREF="#MIDIData_LoadFromSMF">MIDIData_LoadFromSMF</A> correspond to XF data.</LI>
    <LI><A HREF="#MIDIData_SaveAsSMF">MIDIData_SaveAsSMF</A> correspond to XF data.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   1.9
  </TD>
  <TD>
   2009/04/07
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDITrack_InsertSMPTEOffset">MIDITrack_InsertSMPTEOffset</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertSequencerSpecific">MIDITrack_InsertSequencerSpecific</A> is added.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.0
  </TD>
  <TD>
   2009/07/14
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDIEvent_SetTime">MIDIEvent_SetTime</A> and <A HREF="#MIDIEvent_SetTimeSingle">MIDIEvent_SetTimeSingle</A> move note event with duration 0 in wrong order is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_LoadFromBinary">MIDITrack_LoadFromBinary</A> can't load note event with duration 0 correctly is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_LoadFromSMF">MIDITrack_LoadFromSMF</A> can't load note event with duration 0 correctly is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.1
  </TD>
  <TD>
   2009/12/13
  </TD>
  <TD>
   <UL>
    <LI>A bug that malloc(0) may occur is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.2
  </TD>
  <TD>
   2010/02/28
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDITrack_InsertEventBefore">MIDITrack_InsertEventBefore</A> may put note off event at wrong position when inserting note event is fixed.</LI>
    <LI>A bug that <A HREF="#MIDITrack_InsertEventAfter">MIDITrack_InsertEventAfter</A> may put note off event at wrong position when inserting note event is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.3
  </TD>
  <TD>
   2010/07/30
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIData_GetTrack">MIDIData_GetTrack</A> is added.</LI>
    <LI><A HREF="#MIDIData_LoadFromMIDICSV">MIDIData_LoadFromMIDICSV</A> is added.</LI>
    <LI><A HREF="#MIDIData_SaveAsMIDICSV">MIDIData_SaveAsMIDICSV</A> is added.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.4
  </TD>
  <TD>
   2012/01/10
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDIData_LoadFromMIDICSV">MIDIData_LoadFromMIDICSV</A> can't load "\011","\015","\012" in text event as TAB, CR, LF is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_SaveAsMIDICSV">MIDIData_SaveAsMIDICSV</A> can't save TAB, CR, LF in text event as "\011", "\015", "\012" is fixed. Also MIDICSV file's line break code becomes LF.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.5
  </TD>
  <TD>
   2012/02/10
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDIData_LoadFromMIDICSV">MIDIData_LoadFromMIDICSV</A> can't load non-ascii character correctly is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_SaveAsMIDICSV">MIDIData_SaveAsMIDICSV</A> can't save non-ascii character correctly is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.6
  </TD>
  <TD>
   2012/02/19
  </TD>
  <TD>
   <UL>
    <LI>Correspond to both ANSI version and UNICODE version. If you use earlier version's MIDIDataLibrary, you need to compile and build your program again.</LI>
    <LI>In this guide, <A HREF="#MIDIOverview_ANSI_UNICODE">1-6. ANSI version and UNICODE version</A> is added.</LI>
    <LI><A HREF="#MIDIData_LoadFromBinary">MIDIData_LoadFromBinary</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_LoadFromSMF">MIDIData_LoadFromSMF</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_LoadFromCherry">MIDIData_LoadFromCherry</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN>.</LI>
    <LI><A HREF="#MIDIData_LoadFromMIDICSV">MIDIData_LoadFromMIDICSV</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>

    <LI><A HREF="#MIDIData_SaveAsBinary">MIDIData_SaveAsBinary</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_SaveAsSMF">MIDIData_SaveAsSMF</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_SaveAsCherry">MIDIData_SaveAsCherry</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_SaveAsMIDICSV">MIDIData_SaveAsMIDICSV</A>'s pszFileName's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_GetTitle">MIDIData_GetTitle</A>'s pBuf's type is modified from <SPAN CLASS="KEYWORD">char</SPAN>* to TCHAR*, and lLen's unit is modified from bytes to characters.</LI>
    <LI><A HREF="#MIDIData_GetCopyright">MIDIData_GetCopyright</A>'s pBuf's type is modified from <SPAN CLASS="KEYWORD">char</SPAN>* to TCHAR*, and lLen's unit is modified from bytes to characters.</LI>
    <LI><A HREF="#MIDIData_GetComment">MIDIData_GetComment</A>'s pBuf's type is modified from <SPAN CLASS="KEYWORD">char</SPAN>* to TCHAR*, and lLen's unit is modified from bytes to characters.</LI>
    <LI><A HREF="#MIDIData_SetTitle">MIDIData_SetTitle</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_SetCopyright">MIDIData_SetCopyright</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIData_SetComment">MIDIData_SetComment</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_GetName">MIDITrack_GetName</A>'s pBuf's type is modified from <SPAN CLASS="KEYWORD">char</SPAN>* to TCHAR*, and lLen's unit is modified from bytes to characters.</LI>
    <LI><A HREF="#MIDITrack_SetName">MIDITrack_SetName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertTextEvent">MIDITrack_InsertTextEvent</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertTrackName">MIDITrack_InsertTrackName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertInstrumentName">MIDITrack_InsertInstrumentName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertLyric">MIDITrack_InsertLyric</A>'s pszText's type is modifed from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertMarker">MIDITrack_InsertMarker</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN> type to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertCuePoint">MIDITrack_InsertCuePpoint</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertProgramName">MIDITrack_InsertProgramName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDITrack_InsertDeviceName">MIDITrack_InsertDeviceName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateTextEvent">MIDIEvent_CreateTextEvent</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateTrackName">MIDIEvent_CreateTrackName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateInstrumentName">MIDIEvent_CreateInstrumentName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateLyric">MIDIEvent_CreateLyric</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateMarker">MIDIEvent_CreateMarker</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to<SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateCuePoint">MIDIEvent_CreateCuePpoint</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateProgramName">MIDIEvent_CreateProgramName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_CreateDeviceName">MIDIEvent_CreateDeviceName</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
    <LI><A HREF="#MIDIEvent_GetText">MIDIEvent_GetText</A>'s pData's type is modified from <SPAN CLASS="KEYWORD">char</SPAN>* to TCHAR*, and lLen's unit is modified from bytes to characters.</LI>
    <LI><A HREF="#MIDIEvent_SetText">MIDIEvent_SetText</A>'s pszText's type is modified from <SPAN CLASS="KEYWORD">const char</SPAN>* to <SPAN CLASS="KEYWORD">const</SPAN> TCHAR*.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.7
  </TD>
  <TD>
   2012/09/30
  </TD>
  <TD>
   <UL>
    <LI>TPQN base's available resolution midified from 1 - 960[TPQN] to  1 - 32767[TPQN]. <A HREF="#MIDIData_SetTimeBase">MIDIData_SetTimeBase</A>'s caluclation becomes 64bit. But higher resolution than 960[TPQN] is not recommdend.</LI>
    <LI>Tempo's available range becomes 1 - 60000000[microsec/quarter note].</LI>
    <LI>A bug that <A HREF="#MIDIData_LoadFromBinary">MIDIData_LoadFromBinary</A> checks format, tracks, timebase wrong is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_LoadFromSMF">MIDIData_LoadFromSMF</A> checks format, tracks timebase wrong is fixed</LI>
    <LI>A bug that <A HREF="#MIDIData_LoadFromCherry">MIDIData_LoadFromCherry</A> checks format, tracks, timebase wrong is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIData_LoadFromMIDICSV">MIDIData_LoadFromMIDICSV</A> checks format, tracks, timebase wrong is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.8
  </TD>
  <TD>
   2013/05/05
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIDataLib_SetLocale">MIDIDataLib_SetLocale</A> is temporary added.</LI>
    <LI>A bug of MIDIEvent_ToString and MIDIEvent_ToStringEx is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   2.9
  </TD>
  <TD>
   2013/11/10
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDITrack_InsertPatchChange">MIDITrack_InsertPatchChange</A>'s parameter's specfication is modified.</LI>
    <LI><A HREF="#MIDITrack_InsertRPNChange">MIDITrack_InsertPatchChange</A>'s parameter's specification is modified.</LI>
    <LI><A HREF="#MIDITrack_InsertNRPNChange">MIDITrack_InsertPatchChange</A>'s parameter's specification is modified.</LI>
    <LI><A HREF="#MIDIEvent_CreatePatchChange">MIDIEvent_CreatePatchChange</A>'s parameter's specification is modified.</LI>
    <LI><A HREF="#MIDIEvent_CreateRPNChange">MIDIEvent_CreatePatchChange</A>'s parameter's specification is modified.</LI>
    <LI><A HREF="#MIDIEvent_CreateNRPNChange">MIDIEvent_CreatePatchChange</A>'s parameter's specification is modified.</LI>
    <LI><A HREF="#MIDIEvent_CreateSysExEvent">MIDIEvent_CreateSysExEvent</A> is added.</LI>
    <LI>A bug of <A HREF="#MIDIData_LoadFromCherry">MIDIData_LoadFromCherry</A> is fixed.</LI>
    <LI>A bug of <A HREF="#MIDIData_SaveAsCherry">MIDIData_SaveAsCherry</A> is fixed.</LI>
    <LI>MIDIIO.bas is fixed.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.0
  </TD>
  <TD>
   2014/04/29
  </TD>
  <TD>
   <UL>
    <LI>Deveropment software is modified from VisualC++ 4.0 to VisualC++ 2008 Service Pack1.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.1
  </TD>
  <TD>
   2014/05/29
  </TD>
  <TD>
   <UL>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_TextEvent">text</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_CopyrightNotice">copyright notice</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_TrackName">track name</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_InstrumentName">instrument name</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_Lyric">lyric</A> event. (Standard MIDI File RP-026)</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_Marker">marker</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_CuePoint">cue point</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_ProgramName">program name</A> event.</LI>
    <LI>Support char code identifier in <A HREF="#MIDIEvent_DeviceName">device name</A> event.</LI>
    <LI><A HREF="#MIDITrack_InsertTextEventEx">MIDITrack_InsertTextEventEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertCopyrightNoticeEx">MIDITrack_InsertCopyrightNoticeEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertTrackNameEx">MIDITrack_InsertTrackNameEx</A>is added.</LI>
    <LI><A HREF="#MIDITrack_InsertInstrumentNameEx">MIDITrack_InsertInstrumentNameEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertLyricEx">MIDITrack_InsertLyricEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertMarkerEx">MIDITrack_InsertMarkerEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertCuePointEx">MIDITrack_InsertCuePointEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertProgramNameEx">MIDITrack_InsertProgramNameEx</A> is added.</LI>
    <LI><A HREF="#MIDITrack_InsertDeviceNameEx">MIDITrack_InsertDeviceNameEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateTextEventEx">MIDIEvent_CreateTextEventEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateCopyrightNoticeEx">MIDIEvent_CreateCopyrightNoticeEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateTrackNameEx">MIDIEvent_CreateTrackNameEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateInstrumentNameEx">MIDIEvent_CreateInstrumentNameEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateLyricEx">MIDIEvent_CreateLyricEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateMarkerEx">MIDIEvent_CreateMarkerEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateCuePointEx">MIDIEvent_CreateCuePointEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateProgramNameEx">MIDIEvent_CreateProgramNameEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_CreateDeviceNameEx">MIDIEvent_CreateDeviceNameEx</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_GetCharCode">MIDIEvent_GetCharCode</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_SetCharCode">MIDIEvent_SetCharCode</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_GetText">MIDIEvent_GetText</A>'s specification is modified.</LI>
    <LI><A HREF="#MIDIEvent_SetText">MIDIEvent_SetText</A>'s specification is modified.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.2
  </TD>
  <TD>
   2015/05/04
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIData_LoadFromSMF">MIDIData_LoadFromSMF</A>'s reading ability is enhanced.</LI>
    <LI>English version's official guide is added.</LI>
    <LI>In this guide, wrong description is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.3
  </TD>
  <TD>
   2016/04/17
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIDataLib_SetDefaultCharCode">MIDIDataLib_SetDefaultCharCode</A>'s specification is enhanced. If you doesn't specify any char code, MIDIEVENT_NOCHARCODE is applied. If MIDIEVENT_NOCHARCODE, the text encoding specified in the windows's control panel is applied.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.4
  </TD>
  <TD>
   2016/05/08
  </TD>
  <TD>
   <UL>
    <LI>A bug that <A HREF="#MIDIEvent_GetText">MIDIEvent_GetText</A>'s char code specification is wrong is fixed.</LI>
    <LI>A bug that <A HREF="#MIDIEvent_SetText">MIDIEvent_SetText</A>'s char code specification is wrong is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.5
  </TD>
  <TD>
   2017/12/17
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIEvent_GetDataEntryMSB">MIDIEvent_GetDataEntryMSB</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_SetDataEntryMSB">MIDIEvent_SetDataEntryMSB</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_GetPatchNum">MIDIEvent_GetPatchNum</A> is added.</LI>
    <LI><A HREF="#MIDIEvent_SetPatchNum">MIDIEvent_SetPatchNum</A> is added.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.6
  </TD>
  <TD>
   2018/04/15
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIData_LoadFromWRK">MIDIData_LoadFromWRK</A> is added.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.7
  </TD>
  <TD>
   2019/01/03
  </TD>
  <TD>
   <UL>
    <LI>A bug that using <A HREF="#MIDIEvent_SetTime">MIDIEvent_SetTime</A>, <A HREF="#MIDIEvent_SetDuration">MIDIEvent_SetDuration</A>, or <A HREF="#MIDIEvent_SetTimeSingle">MIDIData_SetTimeSingle</A> to a note whose duration = 0 sometimes causes crash is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.8
  </TD>
  <TD>
   2019/05/19
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIData_LoadFromMabiMML">MIDIData_LoadFromMabiMML</A> is added.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   3.9
  </TD>
  <TD>
   2019/11/17
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIEvent_GetValue">MIDIEvent_GetValue</A> is fixed to return 0 even if the channel prefix or port prefix event has no data.</LI>
    <LI><A HREF="#MIDIEvent_GetTempo">MIDIEvent_GetTempo</A> is fixed to return 60000000/120 even if the event has no data.</LI>
    <LI><A HREF="#MIDIEvent_GetSMPTEOffset">MIDIEvent_GetSMPTEOffset</A> is fixed to get a value as possible even if the event has only part of the data.</LI>
    <LI><A HREF="#MIDIEvent_GetTimeSignature">MIDIEvent_GetTimeSignature</A> is fixed to get a value as possible even if the event has only part of the data.</LI>
    <LI><A HREF="#MIDIEvent_GetKeySignature">MIDIEvent_GetKeySignature</A> is fixed to get a value as possible even if the event has only part of the data.</LI>
    <LI><A HREF="#MIDIEvent_SetValue">MIDIEvent_SetValue</A> is fixed not to crash even if the channel prefix or port prefix event has no data.</LI>
    <LI><A HREF="#MIDIEvent_SetTempo">MIDIEvent_SetTempo</A> is fixed not to crash even if the event has no data.</LI>
    <LI><A HREF="#MIDIEvent_SetSMPTEOffset">MIDIEvent_SetSMPTEOffset</A> is fixed to set a value as possible even if the event has only part of the data.</LI>
    <LI><A HREF="#MIDIEvent_SetTimeSignature">MIDIEvent_SetTimeSignature</A> is fixed to set a value as possible even if the event has only part of the data.</LI>
    <LI><A HREF="#MIDIEvent_SetKeySignature">MIDIEvent_SetKeySignature</A> is fixed to set a value as possible even if the event has only part of the data.</LI>
    <LI><A HREF="#MIDIEvent_CreateNoteOn">MIDIEvent_CreateNoteOn</A>'s key number clipping error is fixed.</LI>
   </UL>
  </TD>
 </TR>
 <TR>
  <TD>
   4.0
  </TD>
  <TD>
   2020/01/05
  </TD>
  <TD>
   <UL>
    <LI><A HREF="#MIDIEvent_CreateTextEvent">MIDIEvent_CreateTextEvent</A> has supported UTF-8.</LI>
    <LI><A HREF="#MIDIEvent_CreateTextEventEx">MIDIEvent_CreateTextEventEx</A> has supported UTF-8.</LI>
    <LI><A HREF="#MIDIEvent_GetCharCode">MIDIEvent_GetCharCode</A> has supported UTF-8.</LI>
    <LI><A HREF="#MIDIEvent_GetText">MIDIEvent_GetText</A> has supported UTF-8.</LI>
    <LI><A HREF="#MIDIEvent_SetCharCode">MIDIEvent_SetCharCode</A> has supported UTF-8.</LI>
    <LI><A HREF="#MIDIEvent_SetText">MIDIEvent_SetText</A> has supported UTF-8.</LI>
   </UL>
  </TD>
 </TR>
</TABLE>


</BODY>
</HTML>






